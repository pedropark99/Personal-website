{
  "hash": "a7b2be042e27f7dd0473acd57f8983ad",
  "result": {
    "markdown": "---\ntitle: JOINs são importantes fontes de duplicações em seus dados\ndescription: \"Se os seus dados crescerem de forma repentina, sem explicação aparente, verifique se os seus JOINs são a fonte desse problema\"\ndate: 2023-01-10\nbibliography: \"../bibliography.bib\"\n---\n\n\n\n\n# Introdução\n\n<!--\nA regra de ouro da programação DRY (*do not repeat yourself*) também pode influenciar outras dimensões de sua vida. Por exemplo, se você der o mesmo conselho para uma pessoa pela terceira vez ou mais, é melhor que você escreva ou documente esse conselho de alguma forma. Desse modo, você pode disseminar esse conselho para outras pessoas de forma mais efetiva. Esse post é um reflexo direto disso:\n\n> When you’ve written the same code 3 times, write a function. When you’ve given the same in-person advice 3 times, write a blog post. ROBINSON, David, 2017 ^[Essa citação vem de um tweet de David Robinson, o qual está disponível no link: <https://twitter.com/drob/status/928447584712253440?s=20&t=5gy5SkBKGr6oXsWcg9LIag>].\n-->\n\nQuando estamos construindo uma nova tabela de dados, é muito comum compararmos os nossos resultados com tabelas anteriores e nos depararmos com problemas de divergência nos dados. Isto é, situações como:\n\n> Uhmm... a tabela antiga indica que o número de maquininhas vendidas no mês de Dezembro foi de 1387. Porém, esse mesmo indicador na tabela nova está em 1824 para o mesmo mês de Dezembro. Porque esse aumento?\n\nAumentos desse tipo podem ocorrer por uma variedade de razões. Porém, operações de JOIN tem sido uma razão específica que tenho enfrentado com muita frequência em meu trabalho. Em outras palavras, JOINs são fontes extremamente comuns desse tipo de \"efeito expansivo\", e, muitos analistas não compreendem o porquê, ou não enxergam como isso pode ocorrer. \n\nNesse post, busco justamente esclarecer como uma operação de JOIN pode causar esse \"efeito de aumento\" em seus dados. Eu também explico esse efeito em detalhes no capítulo 6 do meu livro introdutório da linguagem R. Mais especificamente, a partir da seção [Relações entre *keys: primary keys* são menos comuns do que você pensa](https://pedropark99.github.io/Introducao_R/introdu%C3%A7%C3%A3o-a-base-de-dados-relacionais-com-dplyr.html#rela%C3%A7%C3%B5es-entre-keys-primary-keys-s%C3%A3o-menos-comuns-do-que-voc%C3%AA-pensa). Portanto, grande parte do conhecimento exposto aqui são referências diretas ao livro.\n\n\n# Esse efeito independe da linguagem de programação utilizada\n\nPor opção minha, vou utilizar exemplos na linguagem R para demonstrar esse \"efeito expansivo\" de JOINs ao longo desse post. Mas você poderia facilmente transpor todos esses exemplos para qualquer outra linguagem de sua preferência (e.g. como o Python).\n\nOu seja, o conhecimento exposto aqui **independe da linguagem utilizada**. Pois o efeito expansivo descrito aqui é uma característica intrínseca ao processo de JOIN, e não da linguagem utilizada.\n\n\n# Um exemplo de efeito expansivo\n\nPara demonstrar esse efeito expansivo, vou utilizar as tabelas `cores_de_pele` e `alturas` como exemplo. Podemos visualizar os dados dessas duas tabelas abaixo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncores_de_pele\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n     ID Cor    \n  <dbl> <chr>  \n1   100 Pardo  \n2   102 Branco \n3   104 Branco \n4   105 Amarelo\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nalturas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  DataRegistro    ID Altura\n  <date>       <dbl>  <dbl>\n1 2022-01-10     102   1.58\n2 2022-01-10     105   1.72\n3 2022-06-12     105   1.74\n4 2022-08-24     105   1.75\n```\n:::\n:::\n\n\nVamos supor que, no início, você precisava manter um indicador de \"número de usuários por cor de pele\" em um relatório. Para isso, você simplesmente contava o número de linhas na tabela `cores_de_pele` agrupado pelos valores da coluna `Cor`. Como demonstrado abaixo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nusuarios_por_cor <- cores_de_pele |>\n    group_by(Cor) |>\n    summarise(N_usuarios = n())\n\nusuarios_por_cor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  Cor     N_usuarios\n  <chr>        <int>\n1 Amarelo          1\n2 Branco           2\n3 Pardo            1\n```\n:::\n:::\n\n\n\n## Uma nova necessidade\n\nPorém, uma nova necessidade surge no time. Agora, você precisa calcular também a \"altura média por cor de pele\". Você sabe que as alturas dos usuários estão armazenadas na tabela `alturas`, contudo, você precisa trazer essas alturas para dentro da tabela `cores_de_pele`, para que você possa de fato calcular a altura média para cada cor de pele.\n\nPortanto, você precisa realizar um JOIN entre essas tabelas, e é isso que estamos fazendo no código abaixo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- cores_de_pele |>\n    left_join(alturas, by = \"ID\")\n```\n:::\n\n\nAgora, temos uma nova tabela chamada `dados` que contém todos os dados que precisamos para calcular ambos os indicadores (\"número de usuários\" e \"altura média\") para cada cor de pele. Entretanto, quando calculamos esses indicadores com essa tabela `dados`, perceba que o número de usuários (indicador `N_usuarios`) de cor \"Amarelo\" sofreu um aumento repentino.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindicadores <- dados |>\n    group_by(Cor) |>\n    summarise(\n        N_usuarios = n(),\n        Altura_media = mean(Altura, na.rm = TRUE)\n    )\n\nindicadores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  Cor     N_usuarios Altura_media\n  <chr>        <int>        <dbl>\n1 Amarelo          3         1.74\n2 Branco           2         1.58\n3 Pardo            1       NaN   \n```\n:::\n:::\n\n\nRepare que nós não mudamos a fórmula de cálculo do indicador `N_usuarios`. Nós aplicamos a mesma função `n()` que utilizamos anteriormente. Nós também agrupamos a tabela `dados` pela coluna `Cor` com `group_by()`, da mesma forma que fizemos anteriormente. Porque esse aumento ocorreu?\n\nNós não mudamos nada na fórmula de cálculo do indicador `N_usuarios`. Porém, nós introduzimos um novo item na cadeia de transformações da tabela. Mais especificamente, um LEFT JOIN realizado pela função `left_join()`. Ou seja, **o JOIN é o que mudou nesse código**, e ele é o culpado por esse estranho e repentino aumento no número de usuários de cor amarela.\n\n## O que aconteceu?\n\nSe olharmos bem para a tabela resultado do JOIN (tabela `dados`) podemos começar a compreender o que aconteceu. Perceba que temos 6 linhas nessa tabela, isto é, temos 2 linhas a mais que a tabela `cores_de_pele` (que possui 4 linhas). Perceba também que temos 3 linhas nessa tabela descrevendo o mesmo usuário de ID 105.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n     ID Cor     DataRegistro Altura\n  <dbl> <chr>   <date>        <dbl>\n1   100 Pardo   NA            NA   \n2   102 Branco  2022-01-10     1.58\n3   104 Branco  NA            NA   \n4   105 Amarelo 2022-01-10     1.72\n5   105 Amarelo 2022-06-12     1.74\n6   105 Amarelo 2022-08-24     1.75\n```\n:::\n:::\n\n\nO usuário de ID 105 é o único usuário de cor \"Amarelo\" na tabela. Portanto, essas 3 linhas referentes ao ID 105 são a causa da mudança repentina no indicador `N_usuarios` para a cor \"Amarelo\". Porém, a tabela `cores_de_pele` tinha 1 única linha referente ao usuário de ID 105, como você pode ver abaixo. Como essa única linha se transformou em três?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncores_de_pele\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n     ID Cor    \n  <dbl> <chr>  \n1   100 Pardo  \n2   102 Branco \n3   104 Branco \n4   105 Amarelo\n```\n:::\n:::\n\n\n\n<!-- Isso é um fato importante, pois muito analistas tendem a interpretar um LEFT JOIN como um JOIN que resulta em uma nova tabela com o mesmo número de linhas que a tabela à esquerda. Porém, a tabela à esquerda neste exemplo era a tabela `cores_de_pele`, a qual possui 4 linhas, e mesmo assim, o resultado do JOIN foi uma tabela de 6 linhas. -->\n\n\n# O que é um JOIN?\n\nUm processo de JOIN é a união entre duas tabelas. Ou seja, se você tem uma tabela A com colunas `x` e `y`, e uma tabela B com colunas `j`, `k` e `l`, um JOIN entre essas duas tabelas resulta em uma nova tabela com colunas `x`, `y`, `j`, `k` e `l`.\n\nUma característica fundamental de um JOIN, é que ele realiza um processo de pareamento dos dados durante essa união. Ou seja, um JOIN não vai simplesmente unir as colunas `x`, `y`, `j`, `k`, `l` e voa-lá! Temos uma nova tabela. Esse tipo de união que não inclui um processo de pareamento geralmente é denominado de *\"bind\"* ou *\"concatenate\"*, ao invés de *\"join\"*.\n\nPara realizar esse processo de pareamento dos dados, um JOIN utiliza uma coluna (ou um conjunto de colunas) presente em ambas as tabelas como as \"chaves\" do JOIN. Portanto, as *keys*, ou as \"chaves\" de um JOIN são a combinação de colunas utilizadas para realizar o processo de pareamento (ou *matching*) entre os dados das duas tabelas que estão sendo unidas no JOIN. \n\nEm @fig-pareamento, podemos visualizar esse processo de pareamento dos dados. Nesse exemplo, a coluna que representa a \"chave\" do JOIN é a coluna `ID`, pois ela é a única coluna que está presente em ambas as tabelas.\n\n![Processo de pareamento realizado em um JOIN](../pareamento1.png){#fig-pareamento}\n\n\n# Relações entre *keys* de um JOIN\n\nAs \"chaves\" (ou *keys*) de todo JOIN podem formar três tipos de relação: 1) um para um; 2) um para muitos; e 3) muitos para muitos. Em @fig-relacoes apresentamos cada uma dessas relações de forma visual, onde a coluna `key` representa a \"chave\" do JOIN.\n\n![Resumo das relações possíveis entre *keys*](../relacoes_keys.png){#fig-relacoes width=\"80%\"}\n\nPerceba que, para o caso de relação um para um, o número de linhas na tabela resultado permanece inalterado. Porém, as relações que realmente nos interessam nesse post são as relações de \"um para muitos\" e de \"muitos para muitos\". Perceba que algum nível de \"duplicação\" de informações é gerado nesses dois tipos de relação.\n\nÉ através dessa \"duplicação\" que pode ocorrer o que estamos chamando de \"efeito expansivo\" dos JOINs nesse post. **Vale destacar que esse efeito independe do tipo de JOIN que você está realizando**. Pois esse efeito expansivo nasce do processo de pareamento e da relação entre as \"chaves\" do JOIN, e não do tipo de JOIN (*inner, left, right, full*) que você está executando.\n\n\n\n\n# Conclusão\n\nPerceba pelo exemplo acima, que **em nenhum momento nós mudamos a forma** como o indicador `N_usuarios` estava sendo calculado. Porém, o simples fato de introduzirmos um JOIN no caminho gerou uma expansão dos dados que distorceu os valores desse indicador. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}