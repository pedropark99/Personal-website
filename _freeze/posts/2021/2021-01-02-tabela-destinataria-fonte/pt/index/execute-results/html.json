{
  "hash": "4c5fca2189819dd5db0db154e0723f64",
  "result": {
    "markdown": "---\ntitle: \"Tabela destinat√°ria e tabela fonte\"\nsubtitle: \"Uma segunda vis√£o sobre *outer joins*\"\ndescription: \"Um vis√£o diferente (talvez maluca) sobre como ensinar/explicar *Outer joins* para seus alunos\"\n\ncategories: [\"JOINs\", \"Teaching\"]\ndate: 2021-01-02\nimage: \"./../featured.png\"\nprojects: [\"R_curso\"]\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.hljs{\n  font-family: 'Inconsolata', monospace;\n  font-size: 17px;\n}\n\n.hljs.shell{\n  font-size: 18px;\n}\n\n.hljs-comment{\n  font-style: normal;\n  color: #222222;\n}\n</style>\n:::\n\n\n\n\n\n# Introdu√ß√£o\n\n*Outer joins* s√£o um t√≥pico de simples compreens√£o para a maioria dos alunos. Entretanto, esse artigo prop√µe uma segunda abordagem sobre o tema. Tal abordagem foi constru√≠da durante uma reformula√ß√£o recente do cap√≠tulo \"Introdu√ß√£o a base de dados relacionais\" do livro [Introdu√ß√£o √† Linguagem R: seus fundamentos e sua pr√°tica](https://pedro-faria.netlify.app/pt/publication/book/introducao_linguagem_r/). O ponto de vista apresentado aqui, busca ser estrito, e utiliza essa rigidez como um mecanismo que facilite a memoriza√ß√£o do aluno sobre os comportamentos de cada tipo de *outer join*.\n\n# Joins possuem sentido e dire√ß√£o\n\nUma opera√ß√£o de *join* √© nada mais do que uma uni√£o entre duas tabelas. Por outro lado, temos uma outra op√ß√£o de interpreta√ß√£o do resultado dessa opera√ß√£o. De modo que, para produzirmos uma tabela que represente a uni√£o entre duas tabelas, poder√≠amos simplesmente extrair todas as colunas de uma das tabelas, e inser√≠-las na outra tabela.\n\nPor exemplo, suponha que voc√™ possua uma tabela `A`, que cont√©m duas colunas, chamadas `x` e `y`; e uma tabela `B`, que por sua vez, guarda 4 colunas diferentes, denominadas `x`, `z`, `r`, e `t`. Perceba que uma das colunas na tabela `B`, corresponde a mesma coluna `x` que encontramos na tabela `A`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n\nA <- tibble(\n  x = 1:5,\n  y = round(rnorm(5, 2, 1), 2)\n)\n\nB <- tibble(\n  x = 1:5,\n  z = letters[1:5],\n  r = c(3.5, 2.1, 1, 5.6, 7.2),\n  t = \"tzu\"\n)\n```\n:::\n\n\n\nSe voc√™ deseja unir as tabelas `A` e `B`, voc√™ basicamente deseja criar uma nova tabela, que cont√©m todas as cinco colunas dessas duas tabelas (`x`, `y`, `z`, `r` e `t`). Portanto, poder√≠amos imaginar um processo de *join*, como se estiv√©ssemos transportando todas as colunas da tabela `B`, para dentro da tabela `A`. Dessa maneira, temos a tabela abaixo como resultado:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(A, B, by = \"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 5\n      x     y z         r t    \n  <int> <dbl> <chr> <dbl> <chr>\n1     1  1.5  a       3.5 tzu  \n2     2  2.02 b       2.1 tzu  \n3     3  1.34 c       1   tzu  \n4     4  1.24 d       5.6 tzu  \n5     5  2.49 e       7.2 tzu  \n```\n:::\n:::\n\n\n\nCom isso, estamos criando a ideia de que **um *join* possui sempre um sentido e uma dire√ß√£o**. Em outras palavras, primeiro, extra√≠mos as colunas da tabela `B`, e em seguida, acrescentamos essas colunas √† tabela `A`. Repare que estamos sempre partindo da tabela `B` em dire√ß√£o a tabela `A`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](./../direcao.png)\n:::\n:::\n\n\n# Tabela destinat√°ria e tabela fonte\n\nPor essa perspectiva, podemos interpretar que, em um *join*, estamos trazendo todas as colunas de uma tabela secund√°ria, para dentro de nossa tabela principal (ou a nossa tabela de interesse). Temos a op√ß√£o de chamarmos essas tabelas de: **tabela fonte** (tabela secund√°ria) e **tabela destinat√°ria** (tabela principal). Com isso, temos que um *join* sempre parte da **tabela fonte** em dire√ß√£o √† **tabela destinat√°ria**.\n\nEssa perspectiva faz sentido com a pr√°tica de *joins*. Pois em qualquer an√°lise, n√≥s comumente trabalhamos com uma tabela \"principal\", ou uma tabela que cont√©m os principais dados que estamos analisando. E quando utilizamos algum *join*, estamos geralmente trazendo colunas de outras tabelas para dentro dessa tabela \"principal\" (ou tabela \"destinat√°ria\", segundo essa perspectiva). Por isso, tenha em mente que um *join* sempre parte da **tabela fonte** em dire√ß√£o √† **tabela destinat√°ria**.\n\n\n\n# Tipos de *outer join* \n\nUm *join* natural (*inner join*) usualmente gera uma perda de observa√ß√µes de ambas as tabelas envolvidas no processo. Em contrapartida, um *join* do tipo *outer* (isto √©, um *outer join*), busca delimitar qual das duas tabelas ser√° preservada no resultado. Ou seja, um *outer join* busca manter as linhas de pelo menos uma das tabelas envolvidas, no resultado do *join*.\n\nTemos tr√™s tipos principais de *outer joins*, que s√£o *left join*, *right join* e *full join*. O *full join* √© o mais simples de se compreender, pois ele busca manter todas as linhas de ambas as tabelas empregadas. Logo, mesmo que haja alguma observa√ß√£o n√£o encontrada em uma das tabelas, ela ser√° preservada no produto final da opera√ß√£o.\n\nNo entanto, *left join* e *right join* buscam conservar as linhas de apenas uma das tabelas utilizadas no *join*. Nesse ponto, muitos professores diriam algo como: \"se temos desejamos aplicar um *join* entre as tabelas `A` e `B`, um *left join* ir√° manter as linhas da tabela `A` e um *right join* vai manter as linhas da tabela `B`\". Outros professores ainda tentariam dizer: \"*left join* ir√° manter as linhas da tabela √† esquerda, enquanto um *right join* vai manter as linhas da tabela √† direita\". \n\nPor√©m, certa confus√£o pode ser facilmente aplicada em ambas alternativas. Digo, um aluno pode facilmente enfrentar a seguinte quest√£o: \"ü§î Uhmm... Eu n√£o me lembro muito bem. Um *left join* mant√©m as linhas da tabela `A`? Ou s√£o as linhas da tabela `B`?\"; ou ent√£o, \"ü§î Pera! Mas qual das duas tabelas est√° a direita?\".\n\n# Conclus√£o\n\nCom isso, segundo a perspectiva adotada nesse artigo, podemos entender que, um *left join* e um *right join* buscam manter as linhas da **tabela destinat√°ria** e da **tabela fonte**, respectivamente. Dessa forma, ao utilizar um *right join* ou um *left join*, voc√™ deve se questionar o seguinte: \"Eu quero manter as linhas de minha tabela principal (tabela destinat√°ria)? Ou da tabela secund√°ria (tabela fonte), de onde estou extraindo as novas colunas?\". Logo, se voc√™ deseja manter, por exemplo, as linhas de sua tabela principal (tabela destinat√°ria), que √© o que ocorre na maioria das vezes, voc√™ sabe agora que voc√™ precisa utilizar um *left join*.\n\nEm uma representa√ß√£o visual, podemos reproduzir abaixo a imagem inicial desse artigo, que marca as linhas mantidas por cada um desses dois tipos de *join*.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](./../featured.png)\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}