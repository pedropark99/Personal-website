{
  "hash": "c1bf9ae11ad830fb4f19cbe0513206f6",
  "result": {
    "markdown": "---\ntitle: What I learned from developing my first Python package\ndescription: In this post, I want to share some of the challenges, and what I learned from developing my first Python package üì¶ published at PyPI\nimage: \"./../package.jpg\"\n\ndate: 2023-01-30\n\nnumber-sections: true\n---\n\n# Introduction\n\nIn 2022, I developed my first Python package called [`spark_map`](https://github.com/pedropark99/spark_map), and published it at PyPI. If you want to know more about this package üòâ, you can check [a previous post here](https://pedro-faria.netlify.app/posts/2022/2022-12-21-spark-map-v0.2.3/en/), where I introduced the package, and described it's main features, and showed a small use case.\n\nAlthough `spark_map` is a small Python package, I had a hard time developing it. More specifically, the Python code was not hard to develop. But packaging it into a proper package üì¶ was hard. In this post, I want to share a few things that I learned about Python package development in this process.\n\n# Before I say anything, some references\n\nThe development of this package involved reading several articles üìì, and doing some practical tests üß™. Here I share some of the best resources I discovered along the way.\n\nFirst, a great article to start your project is the [Packaging Python Projects](https://packaging.python.org/en/latest/tutorials/packaging-projects/) tutorial. This tutorial is written by PyPA, or, the [Python Packaging Authority](https://www.pypa.io/en/latest/) team[^foot1], and it seems to be \"The Place\" to search for best practices on Python package projects.\n\n[^foot1]: Probably a bad name for a team. But, that is just my opinion.\n\nThe PyPA team also have a very detailed documentation about [Packaging and distributing projects](https://packaging.python.org/en/latest/guides/distributing-packages-using-setuptools/) with `setuptools`. This is a more technical, detailed documentation, but, it can be a great resource too.\n\nAnother very useful article to learn about the structure of a Python package, and the import process of Python, is the article entitled [Dead Simple Python: Project Structure and Imports](https://dev.to/codemouse92/dead-simple-python-project-structure-and-imports-38c6) from Jason C. McDonald.\n\n# Now, let's dive in\n\n## The search path of Python\n\nWe usually import a package in Python, by including a `import` statement at the beginning of our script. For example, to import the `pandas` package to my Python session, I could do this:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas\n```\n:::\n\n\nWhen you import a package in Python, the Python interpreter starts a search process üîç trough your computer, to find the specific package you called in your script. Every Python package you use must be installed in your machine. Otherwise, Python will never find it, and, as a consequence, you can not use it. \n\nThe Python interpreter will always look for the packages you import, inside a set of pre-defined locations of your computer. This pre-defined list is stored inside the `sys.path` variable^[<https://docs.python.org/3/tutorial/modules.html#the-module-search-path>]. In other words, when you import a package, Python looks for this package inside each one of the directories listed at `sys.path` variable. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport sys\nprint(sys.path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['C:\\\\Users\\\\pedro.duarte\\\\Documents\\\\projects\\\\Personal-website\\\\posts\\\\2023\\\\2023-01-30-python-pckg\\\\en', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\python311.zip', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\DLLs', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311', '', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\pedro.duarte\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\Pythonwin']\n```\n:::\n:::\n\n\nYou might also find contents about the `PYTHONPATH` variable when searching for this subject on the internet. In essence, `PYTHONPATH` is a environment variable that can contain a complementary list of directories to be added to `sys.path`^[<https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH>].\n\nAs you can imagine, the Python interpreter look into these directories in a sequential manner. That is, Python looks for the package at the first folder. If it does not find the package you called, then, it looks at the second folder. If it does not find the package again, it looks at the third folder. And goes on and on, until it hits the last folder of the list.\n\nIf does not find the package you called at this last folder, Python will automatically raise a `ModuleNotFoundError` error. As you expect, this error means that Python could not find the package you called at any of the directories listed at `sys.path`.\n\n## Do not change the `sys.path` or `PYTHONPATH` variable ‚ö†Ô∏è\n\nThe `sys.path` variable is a standard Python list, and, as any other list, can be altered to include other directories that are not currently there. The same goes for the `PYTHONPATH` variable, which is an environment variable, and can be altered too. \n\nAs an example, when you try to import your package, which is stored at folder `A`, and, you face a `ModuleNotFoundError` error, you might be tempted to alter `PYTHONPATH` or `sys.path`, to add the folder `A` to this search path of Python. DO NOT DO IT! YOU SHOULD NEVER alter `PYTHONPATH` or `sys.path` ‚ö†Ô∏è ! I mean, at least not inside a Python package.\n\nIn other words, if at some point inside the source code of your Python package, you execute a code like this:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport sys\nsys.path.append('./../weird-unknow-folder')\n```\n:::\n\n\njust erase this code! Python packages are made to be used by other peoples, and with a code like this above, you will change the search path of this user. Changing the search path of a user is a bad idea. Because you can accidentaly produce bad and confusing side effects to the user's session, which can be hard to debug and solve.\n\nBesides, in the majority of times when you alter the `sys.path`, you are trying to overcome a bad structure of your files. In other words, you can always avoid altering the `sys.path` variable by changing the structure of your source files inside your project.\n\nJust to be clear, is a bad idea to alter the `sys.path` inside the source code of your package. However, it is ok to alter these variables outside of your package.\n\nAs a practical example, Apache Spark is written in Scala. But it have an API available to Python trough the `pyspark` package. If you look closely into the source code of the project, or, more specifically at the [`run-tests.py`](https://github.com/apache/spark/blob/master/python/run-tests.py) file, you can see that new paths (or new directories) are appended to `sys.path` in this file.\n\nHowever, this `run-tests.py` file IS NOT A PART of the `pyspark` package itself. It is just an auxiliary script (outside of the package) used to support the testing processes of `pyspark`. This means that `run-tests.py` contains code that is not intended to be executed by the users of the package, but by the developers of `pyspark` instead.\n\n\n## Differences between a package and a module\n\nThis is a very basic knowledge for a Python developer. However, until recently, I did not know the meaning of these two concepts. So, I will give it to you now, in case you do not have it yet.\n\nA Python module is a single Python file (i.e. a file with extension `.py`). Every Python script you write, is a Python module. In contrast, a Python package is a set of Python modules gathered together inside a folder. This folder must contain a particular Python module named as `__init__.py`. This `__init__.py` is the file that \"initialize\", or, \"identifies\" this folder as a Python package^[<https://docs.python.org/3/tutorial/modules.html#packages>].\n\nYou can have multiple Python packages inside a Python package. That is, inside the directory of your package, you can have multiple sub-directories with more Python modules and `__init__.py` files. In this case, these sub-directories become submodules of the package. You can interpret them as sub-packages, if you prefer.\n\n\n## Structuring the package was one of the hardest parts\n\nEvery Python package follows the same basic file/directory structure üèõÔ∏è. In other words, the files that compose a Python package are always structured in a standard way. But, understanding and using this structure effectively was one of the hardest parts for me. At this section, I want to explain this structure for you.\n\nIn a Python package project, you usually have these **files**:\n\n- `LICENSE.md` or `LICENSE.rst` (or both): a text file with the license of your package. It can be a Markdown file (`.md`), or, a reStructuredText markup file (`.rst`);\n- `README.md`: a Markdown file introducing your package. That is, a file that describes succintly the objective of the package, its main features, and showing a small example of use of the package;\n\n- `setup.py` or `pyproject.toml` or `setup.cfg`: these are files used by the build system you choose to build (or compile) your Python package into a compact and shareable format;\n\nAlso, a Python package project usually contains these **folders (or directories)**:\n\n- `src/<package-name>/` or `<package-name>/`: inside this directory you store all Python modules of your package, that is, the source code of your package;\n- `tests/`: inside this directory you store all unit tests of your package. In other words, the scripts and automated workflow used to test your package.\n\n<!--\n- `doc/` or `docs/`: inside this directory you store all documentation files. That is, files that document your package, describe its contents, functionality and concepts;\n-->\n\nYou must store the source code (or the python modules) of your package inside a folder with the same name as the package itself (i.e. the `<package-name>/` folder). So, for a package named `spark_map` we should keep the source files (i.e. the `.py` files) of this package inside a folder called `spark_map`. As a practical example, if you [look at the source code](https://github.com/pandas-dev/pandas/tree/main/pandas) of the famous `pandas` package, you will see that all source code of the package is stored inside a folder called `pandas`.\n\nThis `<package-name>/` folder might be (or might be not) inside another folder called `src/`, that is, the path to the source code might be `src/<package-name>/` instead of `<package-name>/`. The `pandas` package for example, do not uses the `src/` folder, so the source code is stored inside the `pandas/` folder. In contrast, the famous `flask` package uses the `flask/` folder inside a `src/` folder, [so the path to the source code becomes `src/flask`](https://github.com/pallets/flask/tree/main/src/flask).\n\nSo the folder structure to store the source code of the package might change very slightly from package to package. But in general, the source is always stored inside a folder with the same name as the package (i.e. the `<package-name>/` folder).\n\nFurthermore, every project of a Python package usually have one, two, or more files that **control the build process of the package** (like `setup.py`, `pyproject.toml` or `setup.cfg`). In other words, these files are not part of the package itself. But they are used by the **build system** to build (or compile) your package into a compact and shareable format. I talk more about these files at @sec-build-systems.\n\nHaving in mind all these files that we described until here, we can build a example of file structure for a package. For example, a possible file strucuture for a package named `haven` could be:\n\n```\n.\n‚îú‚îÄ‚îÄ LICENSE.md\n‚îú‚îÄ‚îÄ LICENSE.rst\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ pyproject.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îî‚îÄ‚îÄ haven\n‚îÇ       ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ       ‚îú‚îÄ‚îÄ functions.py\n‚îÇ       ‚îú‚îÄ‚îÄ utils.py \n‚îÇ       ‚îî‚îÄ‚îÄ haven.py\n‚îÇ\n‚îî‚îÄ‚îÄ tests\n    ‚îú‚îÄ‚îÄ test_functions.py\n    ‚îî‚îÄ‚îÄ test_haven.py\n```\n\n\n\n## Different build systems behave differently {#sec-build-systems}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}