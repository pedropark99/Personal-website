{
  "hash": "2935fb3dd4e3c1ecf2fe5d8a8dcfe0bf",
  "result": {
    "markdown": "---\ntitle: \"Everything about import statements in Python\"\ndescription: \"Import statements in Python are weird. In this article I want to explain everything you need to know about them. What are they and how they can destroy your hopes in humanity.\"\nnumber-sections: true\nimage: \"./../import-path-py.svg\"\ncategories: ['Python', 'Import statements', 'Package']\ndate: \"2023-11-04\"\n---\n\n# Introduction\n\nThe import system of Python is a little weird, and can cause so much\nheadaches and problems. In this article I want to describe\nhow the import system in Python works, and also, what are\n*import paths* in Python, and how they create so much stress and\nconfusion in some situations.\n\n[^py-docs-import]: <https://docs.python.org/3/reference/import.html>.\n\nFirst of all, the official Python documentation does actually have a pretty detailed\npage about the import system in Python [^py-docs-import]. But my objective here\nis to summarize all you need to know about import paths.\n\n\n# Python module vs Python package\n\nBefore we continue, is good to know a few concepts about Python, like packages\nand modules. In essence, a Python module is a single Python script, or a single\n`.py` file. In contrast, a Python package is basically a bundle (or a collection) of Python modules that can be easily distributed to other peoples.\n\nSo if you have a folder called `scripts`, and, inside of it, you have a Python script\ncalled `date_ranges.py`, then, you have inside this folder a single Python module called `date_ranges.py`. This description represents the following file structure:\n\n```\n└── scripts 📁\n    └── date_ranges.py 📄\n```\n\nNow, let's consider another example, like the following file structure:\n\n```\n└── tea_party 📁\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nLooking at the above structure, we identify a folder called `tea_party`, and 3 different Python modules inside of it. Wait! A Python package is supposed to be a collection of Python modules,\nso, that means that the folder `tea_party` is a Python package, right?\n\nUnfortunately, that is wrong. The `tea_party` folder is not a Python package.\nAt least, not yet. If you consult the official Python documentation, you will\nsee this quote [^py-pkg]:\n\n> A regular package is typically implemented as a directory containing an `__init__.py` file.\n\n[^py-pkg]: https://docs.python.org/3/reference/import.html#regular-packages\n\nSo a Python package is a directory (or a folder) that stores a collection\nof Python modules, but a `__init__.py` file is always part (or a component) of this collection.\nIf we add a `__init__.py` file to `tea_party`, then we make it into an actual Python package.\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nNow, the directory `tea_party` is a Python package, that contains 3 different\nPython modules (`sugar.py`, `water.py` and `cup.py`)\n, apart from the `__init__.py` file, which is mandatory for a Python package.\n\n\n# What is a parent package\n\nAny Python package can contain multiple subpackages inside of it. Every subpackage\nis a single Python package that have a know parent package. For example, take a look at the following\nfile structure:\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n    └── tea 📁\n        └── __init__.py 📄\n        └── black.py 📄\n        └── camomile.py 📄\n```\n\nIn this structure, both `tea_party` and `tea` directories are regular Python packages.\nBut only `tea` is a subpackage, because only `tea` has a know parent package, which is\n`tea_party`. In other words, the package `tea_party` is the parent package of `tea`.\nSo a parent package is a package that contain one or multiple subpackages inside of it.\n\n# Import statements in Python\n\nImport statements in Python are statements used to import functionality from other Python packages or modules, and make them available for you to use in your Python session. In other words, you use import statements to get acess to  functions, classes or variables that are declared in other places, outside of your current Python module.\n\n\nAn import statement always contains the `import` keyword, and they come in two styles (or two formats), which are:\n\n- `import x`\n- `from x import y`\n\nIn the examples above, `x` is a Python package, or a Python module, while `y` might be\n, for example, a subpackage, or a function, or a class declared inside of `x`.\n\nIn the first format, you are basically importing an entire thing. That is, you are importing an entire Python package or a entire Python module to your Python session. In contrast, in the second format, you are importing just a part (or a small piece) of an existing Python package or Python module to your Python session.\n\nJust as a simple example, if I need to see which date is today, I can use an import statement to import the `date` class from the built-in `datetime` Python package, and use the `date.today()` method to get the answer I need.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import date\nprint(date.today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-11-07\n```\n:::\n:::\n\n\nIn this example, I'm using the second format of import statement, because we are importing just the `date` class. In other words, instead of importing the entire `datetime` package, we are importing just a piece of it (which is the `date` class) to our session.\n\nIn essence, we have:\n\n- `import x` = imports the entire package/module (`x`) into your Python session.\n- `from x import y` = imports just a small piece (`y`) of the package/module (`x`) into your Python session.\n\n## Absolute imports\n\n**For now, let's focus on absolute imports**, and forget that relative imports exists. First of all, what is an absolute import? An absolute import means that Python will search the thing you trying to import in two places, which are:\n\n- the directory that contains the Python module from which you are importing.\n- the installed packages/modules in your system.\n\nFor example, if you have inside your Python module an statement like `import pandas`, then, Python will search for the `pandas` package/module first, inside of the directory where this Python module from which you are importing lives. If Python does not find any package/module named as `pandas` in this directory, then, he will search for `pandas` inside of the folder in your system where all of the packages that are currently installed in your system lives.\n\nIn more details, everytime you install a new package in your system, using `pip install`, this new package is installed in a specific folder inside your system. This is the folder where Python will search for `pandas` if he does not find it inside of the directory where the Python module from which you are importing lives.\n\nPython will always import the first version it finds of the package/module you requested. However, if Python does not find a package/module called `pandas` in any of the two places I mentioned, then, Python will most likely raise a `ModuleNotFoundError` error, like this:\n\n```python\nModuleNotFoundError: No module named 'pandas'\n```\n\nMost of the times, this error message means that you are trying to import a package that was supposed to be installed in your system, but unfortunately, it is not installed yet. Because of that, you usually fix this error by effectively installing the package in your system, with a `pip install` command:\n\n```bash\npip install pandas\n```\n\n### `import x` is always an absolute import\n\nEverytime you see an import statement in the format `import x` you know it is an absolute import. When you write an import statement using this format Python will always perform an absolute import.\n\nThis is true because relative imports are not allowed in the format `import x`. That is, relative imports can only be written in the format `from x import y`.\n\n\n\n## Relative imports\n\nThe notion of \"relative imports\" in Python was introduced at [PEP 328](https://peps.python.org/pep-0328/), and are explained in the [Package Relative Imports](https://docs.python.org/3/reference/import.html#package-relative-imports) section of the documentation.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}