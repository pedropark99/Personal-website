{
  "hash": "3b338b9f8824d661cbb61791091cbf3a",
  "result": {
    "markdown": "---\ntitle: \"Everything about import statements in Python\"\ndescription: \"Import statements in Python are weird. In this article I want to explain everything you need to know about them. What are they and how they can destroy your hopes in humanity.\"\nnumber-sections: true\nimage: \"./../import-path-py.svg\"\ncategories: ['Python', 'Import statements', 'Package']\ndate: \"2023-11-04\"\n---\n\n# Introduction\n\nDespite being a core component of the language, the import system of Python\nis a little weird, and can cause some confusion in certain situations.\nIn this article I want to summarize how import references and the import system\nas hole in Python works.\n\n[^py-docs-import]: <https://docs.python.org/3/reference/import.html>.\n\nIs worth noting that the official Python documentation does actually have a pretty long and detailed\npage about the import system in Python [^py-docs-import]. However, my objective in this\narticle is to actually summarize all the knowledge you need to know about the import system,\nso you don't need to read the very long page from the official docs.\n\n\n# Python module vs Python package\n\nPackages and modules in Python are strongly related to the import system. So, if you really want to understand\nthe import system in Python, you need to know what packages and modules are.\nIn essence, a Python module is a single Python script, or a single\n`.py` file. In contrast, a Python package is basically a bundle (or a collection) of Python modules (or Python scripts) that can be easily distributed to other peoples.\n\n\nSo if you have a folder called `scripts`, and, inside of it, you have a single Python script\ncalled `date_ranges.py`, then, you have a single Python module called `date_ranges.py` inside this folder.\nThis description represents the following file structure:\n\n```\n└── scripts 📁\n    └── date_ranges.py 📄\n```\n\n\nNow, let's consider another example, like the following file structure:\n\n```\n└── tea_party 📁\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nLooking at the above structure, we identify a folder called `tea_party`, and 3 different Python modules inside of it. Wait! A Python package is supposed to be a collection of Python modules,\nso, that means that the folder `tea_party` is a Python package, right?\n\nUnfortunately, **that is wrong**. The `tea_party` folder is not a Python package.\nAt least, not yet. If you consult the official Python documentation, you will\nsee this quote [^py-pkg]:\n\n> A regular package is typically implemented as a directory containing an `__init__.py` file.\n\n[^py-pkg]: https://docs.python.org/3/reference/import.html#regular-packages\n\nSo, yes, a Python package is a directory (or a folder) that stores a collection\nof Python modules. But a `__init__.py` file is always part (or a component) of this collection of Python modules.\nIf we add a `__init__.py` file to `tea_party`, then, the folder `tea_party` transforms into an actual Python package.\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nNow, the directory `tea_party` is a Python package, that contains 3 different\nPython modules (`sugar.py`, `water.py` and `cup.py`)\n, apart from the `__init__.py` file, which is mandatory for a Python package.\n\n\n# What is a parent package\n\nAny Python package can contain multiple subpackages inside of it. Every subpackage\nis a single Python package that have a know parent package. For example, take a look at the following\nfile structure:\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n    └── tea 📁\n        └── __init__.py 📄\n        └── black.py 📄\n        └── camomile.py 📄\n```\n\nIn this structure, both `tea_party` and `tea` directories are regular Python packages.\nBut only `tea` is a subpackage, because only `tea` has a know parent package, which is\n`tea_party`. In other words, the package `tea_party` is the parent package of `tea`.\nSo a parent package is a package that contain one or multiple subpackages inside of it.\n\n# Import statements in Python\n\nImport statements in Python are statements used to import functionality from other Python packages or modules, and make them available for you to use in your Python session. In other words, you use import statements to get acess to functions, classes or variables that are declared in other places, outside of your current Python script.\n\nAn import statement always contains the `import` keyword, and they come in two styles (or two formats), which are:\n\n- `import x`\n- `from x import y`\n\nIn the examples above, `x` is a Python package, or a Python module, while `y` might be\n, for example, a subpackage, or a function, or a class declared inside of `x`.\n\n## Differences between the two formats of import statements\n\nThe main difference between the two formats we mentioned above, is that in the first format (`import x`), you are basically **importing an entire thing**. That is, you are importing an entire Python package or a entire Python module to your Python session. In contrast, in the second format (`from x import y`), you are **importing just a part** (or a small piece) of an existing Python package or Python module to your Python session.\n\nJust as a simple example, if I need to see which date is today, I can use an import statement to import the `date` class from the built-in `datetime` Python package, and use the `date.today()` method to get the answer I need.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import date\nprint(date.today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-11-15\n```\n:::\n:::\n\n\nIn this example, I'm using the second format of import statement (`from x import y`), because we are importing just the `date` class. In other words, instead of importing the entire `datetime` package, we are importing just a piece of it (which is the `date` class) to our session.\n\nSo, in essence, we have:\n\n- `import x` = imports the entire package/module (`x`) into your Python session.\n- `from x import y` = imports just a small piece (`y` - which can be a subpackage, or a funcion, or a class, etc.) of the package/module (`x`) into your Python session.\n\n## Absolute references vs relative references\n\nThe are two types of *paths* (or references) you can use in import statements, which are absolute or relative. An absolute path (or an absolute reference) is probably the style you are more familiar with, because you see it all the time in Python code. As an example, all three import statements below uses an absolute path, or an absolute reference to an existing package.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# All of these three statements uses\n# absolute references to existing packages.\nimport datetime\nimport itertools\nimport re\n```\n:::\n\n\nIn contrast, the two statements below uses a relative path, or a relative reference. In these statements, we are importing the function `read_text_file()`, and the classes `Parser` and `Tokenizer` from the local `utils` and `parser` modules.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# The two statements below uses\n# relative references\nfrom .utils import read_text_file\nfrom .parser import Parser, Tokenizer\n```\n:::\n\n\nThe notion of \"relative imports\" in Python was introduced at [PEP 328](https://peps.python.org/pep-0328/), and are explained in the [Package Relative Imports](https://docs.python.org/3/reference/import.html#package-relative-imports) section of the documentation.\n\nYou can see in the above examples that a relative reference uses a dot at the beggining of the module name, like `.utils` and `.parser`. In other words, if you see a reference to something without a dot, like `datetime`, then, it is an absolute reference, but in contrast, a reference that does have a dot that precedes the reference's name, like `.foo`, `.utils` or `.renderer` are examples of relative references.\n\nThe core difference between a relative reference and an absolute reference is how Python will search for the reference you asked for. When you use an absolute reference, then, Python will use the Python search path to find the reference you asked for. In constrast, when you use a relative reference, then, Python will ignore the \"Python search path\", and search for the reference you asked for inside the folder where your script is located.\n\n### The Python search path\n\nWhen you import a package in Python, the Python interpreter starts a search process 🔍 through your computer, to find the specific package (or module) you called in your script. Every Python package you use must be installed in your machine. Otherwise, Python will never find it, and, as a consequence, you can not use it.\n\nWhen you use an absolute reference, the Python interpreter will look for the packages you imported inside a set of pre-defined locations of your computer. This pre-defined list is stored inside the `sys.path` variable. This `sys.path` variable represents the Python search path. So, when you import a package, Python looks for this package inside each one of the directories listed at `sys.path` variable. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport sys\nprint(sys.path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['C:\\\\Users\\\\pedro\\\\Documents\\\\Personal-website\\\\posts\\\\2023\\\\2023-10-30-python-pkg\\\\en', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\python311.zip', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\DLLs', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311', '', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\pedro\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python311\\\\Lib\\\\site-packages\\\\Pythonwin']\n```\n:::\n:::\n\n\nAs you can imagine, the Python interpreter look into these directories in a sequential manner. That is, Python looks for the package at the first folder. If it does not find the package you called, then, it looks at the second folder. If it does not find the package again, it looks at the third folder. And goes on and on, until it hits the last folder on the list.\n\nIf does not find the package you called at this last folder, Python will automatically raise a `ModuleNotFoundError` error. As you expect, this error means that Python could not find the package you called at any of the directories listed at `sys.path`.\n\n\n\n\n### `import x` always use an absolute reference\n\nEverytime you see an import statement in the format `import x` you know it is an absolute import. In other words, when you write an import statement using the format `import x`, then, this import statement will always search for an absolute reference.\n\nThis is true because relative imports are not allowed in the format `import x`. That is, statements like `import .utils` are not allowed. You use a relative reference only in import statements written in the format `from x import y`.\n\n### `from x import y` might use an absolute or a relative reference\n\nOn the other side, a statement in the format `from x import y` can use both relative and absolute references. You will identify which of the two reference types it uses by looking for the dot character which precedes the reference names in relative references.\n\nThat is, a statement like `from datetime import date` uses an absolute reference only because the `datetime` reference does not have a dot before it. If we add a dot, transforming it into `from .datetime import date`, then, the `.datetime` reference becomes a relative reference.\n\n\n\n## Using absolute references\n\n**For now, let's focus on absolute imports**, and forget that relative imports exists. First of all, what is an absolute import? An absolute import means that Python will search the thing you trying to import in two places, which are:\n\n- the directory that contains the Python module from which you are importing.\n- the installed packages/modules in your system.\n\nFor example, if you have inside your Python module an statement like `import pandas`, then, Python will search for the `pandas` package/module first, inside of the directory where this Python module from which you are importing lives. If Python does not find any package/module named as `pandas` in this directory, then, he will search for `pandas` inside of the folder in your system where all of the packages that are currently installed in your system lives.\n\nIn more details, everytime you install a new package in your system, using `pip install`, this new package is installed in a specific folder inside your system. This is the folder where Python will search for `pandas` if he does not find it inside of the directory where the Python module from which you are importing lives.\n\n### Be sure that the package is installed in your system\n\nPython will always import the first version it finds of the package/module you requested. However, if Python does not find a package/module called `pandas` in any of the two places I mentioned, then, Python will most likely raise a `ModuleNotFoundError` error, like this:\n\n```python\nModuleNotFoundError: No module named 'pandas'\n```\n\nMost of the times, this error message means that you are trying to import a package that was supposed to be installed in your system, but unfortunately, it is not installed yet. Because of that, you usually fix this error by effectively installing the package in your system, with a `pip install` command:\n\n```bash\npip install pandas\n```\n\n\n\n### Using absolute imports inside a Python package\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}