{
  "hash": "8e77d8abcb52b63128d183e08143732e",
  "result": {
    "markdown": "---\ntitle: \"Everything about import statements in Python\"\ndescription: \"Import statements are actually weird in Python. In this article I want to explain everything you need to know about import statements. What are they, how they live, and how they can destroy your hopes in humanity.\"\nnumber-sections: true\nimage: \"./../import-path-py.svg\"\ncategories: ['Python', 'Import statements', 'Package']\ndate: \"2023-11-04\"\n---\n\n# Introduction\n\nThe import system of Python is a little weird, and can cause so much\nheadaches and problems. In this article I want to describe\nhow the import system in Python works, and also, what are\n*import paths* in Python, and how they create so much stress and\nconfusion in some situations.\n\n[^py-docs-import]: <https://docs.python.org/3/reference/import.html>.\n\nFirst of all, the official Python documentation does actually have a pretty detailed\npage about the import system in Python [^py-docs-import]. But my objective here\nis to summarize all you need to know about import paths.\n\n\n# Python module vs Python package\n\nBefore we continue, is good to know a few concepts about Python, like packages\nand modules. In essence, a Python module is a single Python script, or single\n`.py` file. In contrast, a Python package is basically a bundle (or a collection) of Python modules that can be\neasily distributed to other peoples.\n\nSo if you have a folder called `scripts`, and, inside of it, you have a Python script\ncalled `date_ranges.py`, then, you have inside this folder a single Python module called `date_ranges.py`. This description represents the following file structure:\n\n```\n└── scripts 📁\n    └── date_ranges.py 📄\n```\n\nNow, let's consider another example, like the following file structure:\n\n```\n└── tea_party 📁\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nLooking at the above structure, we identify a folder called `tea_party`, and 3 different Python scripts inside of it.\nIn other words, you just have a folder called `tea_party` that contains 3 different Python modules. Wait! A Python package is not supposed to be a collection of Python modules?\nSo, that means that the folder `tea_party` is a Python package, right?\n\nUnfortunately, that is wrong. The `tea_party` folder is not a Python package.\nAt least, not yet. If you consult the official Python documentation, you will\nsee this quote [^py-pkg]:\n\n> A regular package is typically implemented as a directory containing an `__init__.py` file.\n\n[^py-pkg]: https://docs.python.org/3/reference/import.html#regular-packages\n\nSo a Python package is a directory (or a folder) that stores a collection\nof Python modules, but a `__init__.py` file is always part (or a component) of this collection.\nHaving this in mind, to make `tea_party` an actual Python package, all we need to do is to add a `__init__.py` file inside the folder.\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n```\n\nNow, the directory `tea_party` is an actual Python package, that contains 3 different\nPython modules (`sugar.py`, `water.py` and `cup.py`)\n, apart from the `__init__.py` file, which is mandatory for a Python package.\n\n\n# What is a parent package\n\nAny Python package can contain multiple subpackages inside of it. Every subpackage\nis a small package that have a know parent package. For example, take a look at the following\nfile structure:\n\n```\n└── tea_party 📁\n    └── __init__.py 📄\n    └── water.py 📄\n    └── sugar.py 📄\n    └── cup.py 📄\n    └── tea 📁\n        └── __init__.py 📄\n        └── black.py 📄\n        └── camomile.py 📄\n```\n\nIn this structure, both `tea_party` and `tea` directories are regular Python packages.\nBut only `tea` is a subpackage, because only `tea` has a know parent package, which is\n`tea_party`. In other words, the package `tea_party` is the parent package of `tea`.\nSo a parent package is a package that contain one or multiple subpackages inside of it.\n\n# Import statements in Python\n\nImport statements in Python are statements that contains the `import` keyword.\nThere are two styles (or two formats) of import statements in Python, which are:\n\n- `import x`\n- `from x import y`\n\nIn the examples above, `x` is a Python package, or a Python module, while `y` might be\n, for example, a subpackage, or a function declared inside of `x`.\n\nThe first format is always an absolute import, while the second format might be\nan absolute import or a relative import. But in the first format, you are basically\nimporting a entire Python package or a entire Python module into your Python\nsession. In contrast, at the second format, you are importing just a part (or pieces)\nof an existing Python package or Python module.\n\nJust as an simple example, if I need to see which date is today,\nI can use an import statement to import the `date` class\nfrom the built-in `datetime` package, and use the `date.today()` method to get\nthe answer I need.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import date\nprint(date.today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-11-03\n```\n:::\n:::\n\n\nThis example uses the second format of import statement, because we are importing\njust the `date` class. Instead of import the entire `datetime` package, we are\nimporting just a piece of it (which is the `date` class) to our session.\n\n\n## Absolute imports\n\n**For now, let's focus on absolute imports**, and forget that relative imports exists.\nAn absolute import means that you are importing something using the `sys.path` variable\nof your session.\n\n\n## Relative imports\n\nThe notion of \"relative imports\" in Python was introduced at [PEP 328](https://peps.python.org/pep-0328/), and are explained in [Package Relative Imports](https://docs.python.org/3/reference/import.html#package-relative-imports) section of the documentation.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}