---
title: "How strings work in Zig?"
description: "A quick introduction to string literals in Zig, and how strings in Zig differ from strings in other programming languages."
date: "2023-12-12"
---

# Introduction

Zig is a new general-purpose and low level programming language that is being very promising. The language have very strong advantages. However,
it still have a weakness which is it's documentation.

The language reference is very good in quality, but it lacks some very specific
details that help us understand better the ground we are stepping in.
Unforntunately, this is a symptom of being a very new language, that is still being developed, with a small community.


That is why I want to help, by using this article to discuss in more depth how strings work in Zig, and give you some more specific details about it.

```{=html}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<script
  type="text/javascript"
  src="https://notabug.org/Ash/highlightjs-zig/raw/master/dist/zig.min.js"
></script>


<script>hljs.highlightAll();</script>
```


# What strings in Zig are?

Because Zig is a low level language, strings might work very differently from other languages.
In Zig, a string literal (or a string object if you prefer) is a pointer to a null-terminated array of bytes. Each byte in this
array is represented by an `u8` value, which is an unsigned 8 bit integer.

Zig always assumes that this sequence of bytes is UTF-8 encoded. This might not be true for every sequence of bytes you have it.
If your string literal is not UTF-8 encoded then, you will probably have problems in Zig.

Let's take for example the word "Hello". In UTF-8, this sequence of characters is represented by the sequence of decimal numbers
72, 101, 108, 108, 111. In xecadecimal, this is the sequence `0x48`, `0x65`, `0x6C`, `0x6C`, `0x6F`. So if I take this sequence
of hexadecimal values, and ask Zig to print this sequence of bytes as a sequence of characters (i.e. a string), then,
the text "Hello" will be printed into the terminal:


```{=html}
<pre><code class="zig">
const std = @import("std");

pub fn main() !void {
    const bytes = [_]u8{0x48, 0x65, 0x6C, 0x6C, 0x6F};
    std.debug.print("{s}\n", .{bytes});
}
</code></pre>
```

```text
Hello
```



# Strings in C

This is very similar to how C treats strings as well. But one key difference between a Zig string and a C string, is that Zig also stores the length of the array inside
the string object. This small detail makes your code safer, because is much easier for the Zig compiler to check if you are trying to access
an element out of bounds, or if your trying to access memory that does not belong to you.

This same kind of safety is not automatic and much harder to do in C.
As a result, in C, you need to loop through the array, and find the null element (`'\0'`) position to discover where exactly the
array ends, or, in other words, to find how much elements the array of bytes contain. It would be something like this in C:

```c
#include <stdio.h>
int main() {
    char* array = "An example of string in C";
    int index = 0;
    while (1) {
        if (array[index] == '\0') {
	    break;
	}
        index++;
    }
    printf("Number of elements in the array: %d\n", index);
}
```

```text
Number of elements in the array: 25
```

But in Zig, you do not have to do this, because the object already contains a `len` field which stores the length information of the array.
As an example, the `string_literal` object below is 43 bytes long:

```{=html}
<pre><code class="zig">
const std = @import("std");

pub fn main() !void {
    const string_literal = "This is an example of string literal in Zig";
    std.debug.print("{d}\n", .{string_literal.len});
}
</code></pre>
```
```text
43
```

# A better look at the object type

Now, we can inspect better the type of objects that Zig create. To check the type of any object in Zig,
you can use the `@TypeOf()` function.

If we look at the type of the `simple_array` object below, you will find that this object is a array of 4 elements.
Each element is a signed integer of 32 bits (`i32`). That is what an object of type `[4]i32` is.

But if we look closely at the type of the `string_literal` object below, you will find that this object is a constant pointer (`*const`) to an array
of 43 elements (or 43 bytes). Each element is a single byte (more precisely, an unsigned 8 bit integer), that is why we have the `[43:0]u8` portion of the type below.
In other words, the string stored inside the `string_literal` object is 43 bytes long. That is why you have the type `*const [43:0]u8` below.

Now, if we create an pointer to the array object, then, we get a constant pointer to an array of 4 elements (`*const [4]i32`),
which is very similar to the type of the `string_literal` object. This demonstrates that a string object (or a string literal) in Zig is already
a pointer to an array.

Just remember that a "pointer to an array" is different than an "array". So a string object in Zig is a pointer to an array of bytes, and
not simply an array of bytes.


```{=html}
<pre><code class="zig">
const std = @import("std");
const print = std.debug.print;

pub fn main() !void {
    const string_literal = "This is an example of string literal in Zig";
    const simple_array = [_]i32{1, 2, 3, 4};


    print("Type of array object: {}\n", .{@TypeOf(simple_array)});
    print("Type of string object: {}\n", .{@TypeOf(string_literal)});
    print("Type of a pointer that points to the array object: {}\n", .{@TypeOf(&simple_array)});
}
</code></pre>
```

```text
Type of array object: [4]i32
Type of string object: *const [43:0]u8
Type of a pointer that points to the array object: *const [4]i32
```
