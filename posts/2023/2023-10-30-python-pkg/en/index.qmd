---
title: "Everything about import statements in Python"
description: "Import statements in Python are weird. In this article I want to explain everything you need to know about them. What are they and how they can destroy your hopes in humanity."
number-sections: true
image: "./../import-path-py.svg"
categories: ['Python', 'Import statements', 'Package']
date: "2023-11-04"
---

# Introduction

Despite being a core component of the language, the import system of Python
is a little weird, and can cause some confusion in certain situations.
In this article I want to summarize how import references and the import system
as hole in Python works.

[^py-docs-import]: <https://docs.python.org/3/reference/import.html>.

Is worth noting that the official Python documentation does actually have a pretty long and detailed
page about the import system in Python [^py-docs-import]. However, my objective in this
article is to actually summarize all the knowledge you need to know about the import system,
so you don't need to read the very long page from the official docs.


# Python module vs Python package

Packages and modules in Python are strongly related to the import system. So, if you really want to understand
the import system in Python, you need to know what packages and modules are.
In essence, a Python module is a single Python script, or a single
`.py` file. In contrast, a Python package is basically a bundle (or a collection) of Python modules (or Python scripts) that can be easily distributed to other peoples.


So if you have a folder called `scripts`, and, inside of it, you have a single Python script
called `date_ranges.py`, then, you have a single Python module called `date_ranges.py` inside this folder.
This description represents the following file structure:

```
â””â”€â”€ scripts ğŸ“
    â””â”€â”€ date_ranges.py ğŸ“„
```


Now, let's consider another example, like the following file structure:

```
â””â”€â”€ tea_party ğŸ“
    â””â”€â”€ water.py ğŸ“„
    â””â”€â”€ sugar.py ğŸ“„
    â””â”€â”€ cup.py ğŸ“„
```

Looking at the above structure, we identify a folder called `tea_party`, and 3 different Python modules inside of it. Wait! A Python package is supposed to be a collection of Python modules,
so, that means that the folder `tea_party` is a Python package, right?

Unfortunately, **that is wrong**. The `tea_party` folder is not a Python package.
At least, not yet. If you consult the official Python documentation, you will
see this quote [^py-pkg]:

> A regular package is typically implemented as a directory containing an `__init__.py` file.

[^py-pkg]: https://docs.python.org/3/reference/import.html#regular-packages

So, yes, a Python package is a directory (or a folder) that stores a collection
of Python modules. But a `__init__.py` file is always part (or a component) of this collection of Python modules.
If we add a `__init__.py` file to `tea_party`, then, the folder `tea_party` transforms into an actual Python package.

```
â””â”€â”€ tea_party ğŸ“
    â””â”€â”€ __init__.py ğŸ“„
    â””â”€â”€ water.py ğŸ“„
    â””â”€â”€ sugar.py ğŸ“„
    â””â”€â”€ cup.py ğŸ“„
```

Now, the directory `tea_party` is a Python package, that contains 3 different
Python modules (`sugar.py`, `water.py` and `cup.py`)
, apart from the `__init__.py` file, which is mandatory for a Python package.


# What is a parent package

Any Python package can contain multiple subpackages inside of it. Every subpackage
is a single Python package that have a know parent package. For example, take a look at the following
file structure:

```
â””â”€â”€ tea_party ğŸ“
    â””â”€â”€ __init__.py ğŸ“„
    â””â”€â”€ water.py ğŸ“„
    â””â”€â”€ sugar.py ğŸ“„
    â””â”€â”€ cup.py ğŸ“„
    â””â”€â”€ tea ğŸ“
        â””â”€â”€ __init__.py ğŸ“„
        â””â”€â”€ black.py ğŸ“„
        â””â”€â”€ camomile.py ğŸ“„
```

In this structure, both `tea_party` and `tea` directories are regular Python packages.
But only `tea` is a subpackage, because only `tea` has a know parent package, which is
`tea_party`. In other words, the package `tea_party` is the parent package of `tea`.
So a parent package is a package that contain one or multiple subpackages inside of it.

# Import statements in Python

Import statements in Python are statements used to import functionality from other Python packages or modules, and make them available for you to use in your Python session. In other words, you use import statements to get acess to functions, classes or variables that are declared in other places, outside of your current Python script.

An import statement always contains the `import` keyword, and they come in two styles (or two formats), which are:

- `import x`
- `from x import y`

In the examples above, `x` is a Python package, or a Python module, while `y` might be
, for example, a subpackage, or a function, or a class declared inside of `x`.

## Differences between the two formats of import statements

The main difference between the two formats we mentioned above, is that in the first format (`import x`), you are basically **importing an entire thing**. That is, you are importing an entire Python package or a entire Python module to your Python session. In contrast, in the second format (`from x import y`), you are **importing just a part** (or a small piece) of an existing Python package or Python module to your Python session.

Just as a simple example, if I need to see which date is today, I can use an import statement to import the `date` class from the built-in `datetime` Python package, and use the `date.today()` method to get the answer I need.

```{python}
from datetime import date
print(date.today())
```

In this example, I'm using the second format of import statement (`from x import y`), because we are importing just the `date` class. In other words, instead of importing the entire `datetime` package, we are importing just a piece of it (which is the `date` class) to our session.

So, in essence, we have:

- `import x` = imports the entire package/module (`x`) into your Python session.
- `from x import y` = imports just a small piece (`y` - which can be a subpackage, or a funcion, or a class, etc.) of the package/module (`x`) into your Python session.

## Absolute references vs relative references

The are two types of *paths* (or references) you can use in import statements, which are absolute or relative. An absolute path (or an absolute reference) is probably the style you are more familiar with, because you see it all the time in Python code. As an example, all three import statements below uses an absolute path, or an absolute reference to an existing package.

```{python}
# All of these three statements uses an
# absolute reference to an existing package.
import datetime
import itertools
import re
```

In contrast, the two statements below uses a relative path, or a relative reference. In these statements, we are importing the function `read_text_file()`, and the classes `Parser` and `Tokenizer` from the local `utils` and `parser` modules.

```{python}
#| eval: false
# The two statements below uses a
# relative reference
from .utils import read_text_file
from .parser import Parser, Tokenizer
```

The notion of "relative imports" in Python was introduced at [PEP 328](https://peps.python.org/pep-0328/), and are explained in the [Package Relative Imports](https://docs.python.org/3/reference/import.html#package-relative-imports) section of the documentation.

You can see in the above examples that a relative reference uses a dot at the beggining of the module name, like `.utils` and `.parser`. In other words, if you see a reference to something without a dot, like `datetime`, then, it is an absolute reference, but in contrast, a reference that does have a dot that precedes the reference's name, like `.foo`, `.utils` or `.renderer` are examples of relative references.

### `import x` always use an absolute reference

Everytime you see an import statement in the format `import x` you know it is an absolute import. In other words, when you write an import statement using the format `import x`, then, this import statement will always search for an absolute reference.

This is true because relative imports are not allowed in the format `import x`. That is, statements like `import .utils` are not allowed. You use a relative reference only in import statements written in the format `from x import y`.

### `from x import y` might use an absolute or a relative reference

On the other side, a statement in the format `from x import y` can use both relative and absolute references. You will identify which of the two reference types it uses by looking for the dot character which precedes the reference names in relative references.

That is, a statement like `from datetime import date` uses an absolute reference only because the `datetime` reference does not have a dot before it. If we add a dot, transforming it into `from .datetime import date`, then, the `.datetime` reference becomes a relative reference.


## Using absolute references

**For now, let's focus on absolute imports**, and forget that relative imports exists. First of all, what is an absolute import? An absolute import means that Python will search the thing you trying to import in two places, which are:

- the directory that contains the Python module from which you are importing.
- the installed packages/modules in your system.

For example, if you have inside your Python module an statement like `import pandas`, then, Python will search for the `pandas` package/module first, inside of the directory where this Python module from which you are importing lives. If Python does not find any package/module named as `pandas` in this directory, then, he will search for `pandas` inside of the folder in your system where all of the packages that are currently installed in your system lives.

In more details, everytime you install a new package in your system, using `pip install`, this new package is installed in a specific folder inside your system. This is the folder where Python will search for `pandas` if he does not find it inside of the directory where the Python module from which you are importing lives.

### Be sure that the package is installed in your system

Python will always import the first version it finds of the package/module you requested. However, if Python does not find a package/module called `pandas` in any of the two places I mentioned, then, Python will most likely raise a `ModuleNotFoundError` error, like this:

```python
ModuleNotFoundError: No module named 'pandas'
```

Most of the times, this error message means that you are trying to import a package that was supposed to be installed in your system, but unfortunately, it is not installed yet. Because of that, you usually fix this error by effectively installing the package in your system, with a `pip install` command:

```bash
pip install pandas
```



### Using absolute imports inside a Python package




