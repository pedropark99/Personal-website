---
title: "Everything about import statements in Python"
description: "An article that summarizes everything you need to know about the import system in Python."
number-sections: true
image: "./../import-path-py.svg"
categories: ['Python', 'Import statements', 'Package']
date: "2023-11-04"
---

# Introduction

In this article I want to summarize everything you need to know
about the import system in Python. How import statements works, what are the types of
references you can use, and how they affect the way Python searches for things.

[^py-docs-import]: <https://docs.python.org/3/reference/import.html>.

First of all, the official Python documentation does actually have a pretty detailed
page about the import system [^py-docs-import]. But it is a pretty long page, so my objective here
is to summarize all you need to know about it.


# The three essential things

There are three important things (or aspects) that affect the way that the import system in Python works. These things are:

1. the format of import statement you use (`from x import y`? or `import x`?).
2. the type of reference you use in the import statement (i.e. it is an absolute reference? or a relative reference?).
3. the context you are in (are you developing a package? or you are just writing a few Python scripts without a `__init__.py` file?).

All of these three aspects can affect the way that the import system works, and how the things you ask for are imported. I will describe each one of these aspects through this article.


# Python module vs Python package

Packages and modules in Python are strongly related to the import system. So, if you really want to understand the import system in Python, you need to know what packages and modules are. In essence, a Python module is a single Python script, or a single `.py` file. In contrast, a Python package is basically a bundle (or a collection) of Python modules (or Python scripts) that can be easily distributed to other peoples.


So if you have a folder called `scripts`, and, inside of it, you have a single Python script called `date_ranges.py`, then, you have a single Python module called `date_ranges.py` inside this folder. This description represents the following file structure:

```
‚îî‚îÄ‚îÄ scripts üìÅ
    ‚îî‚îÄ‚îÄ date_ranges.py üìÑ
```


Now, let's consider another example, like the following file structure:

```
‚îî‚îÄ‚îÄ tea_party üìÅ
    ‚îî‚îÄ‚îÄ water.py üìÑ
    ‚îî‚îÄ‚îÄ sugar.py üìÑ
    ‚îî‚îÄ‚îÄ cup.py üìÑ
```

Looking at the above structure, we identify a folder called `tea_party`, and 3 different Python modules inside of it. Wait! A Python package is supposed to be a collection of Python modules, so, that means that the folder `tea_party` is a Python package, right?

Unfortunately, **that is wrong**. The `tea_party` folder is not a Python package. At least, not yet. If you consult the official Python documentation, you will see this quote [^py-pkg]:

> A regular package is typically implemented as a directory containing an `__init__.py` file.

[^py-pkg]: https://docs.python.org/3/reference/import.html#regular-packages

So, yes, a Python package is a directory (or a folder) that stores a collection of Python modules. But a `__init__.py` file is always part (or a component) of this collection of Python modules. If we add a `__init__.py` file to `tea_party`, then, the folder `tea_party` transforms into an actual Python package.

```
‚îî‚îÄ‚îÄ tea_party üìÅ
    ‚îî‚îÄ‚îÄ __init__.py üìÑ
    ‚îî‚îÄ‚îÄ water.py üìÑ
    ‚îî‚îÄ‚îÄ sugar.py üìÑ
    ‚îî‚îÄ‚îÄ cup.py üìÑ
```

Now, the directory `tea_party` is a Python package, that contains 3 different Python modules (`sugar.py`, `water.py` and `cup.py`), apart from the `__init__.py` file, which is mandatory for a Python package.


# What is a parent package?

Any Python package can contain multiple subpackages inside of it. Every subpackage is a single Python package that have a know parent package. For example, take a look at the following file structure:

```
‚îî‚îÄ‚îÄ tea_party üìÅ
    ‚îî‚îÄ‚îÄ __init__.py üìÑ
    ‚îî‚îÄ‚îÄ water.py üìÑ
    ‚îî‚îÄ‚îÄ sugar.py üìÑ
    ‚îî‚îÄ‚îÄ cup.py üìÑ
    ‚îî‚îÄ‚îÄ tea üìÅ
        ‚îî‚îÄ‚îÄ __init__.py üìÑ
        ‚îî‚îÄ‚îÄ black.py üìÑ
        ‚îî‚îÄ‚îÄ camomile.py üìÑ
```

In this structure, both `tea_party` and `tea` directories are regular Python packages. But only `tea` is a subpackage, because only `tea` has a know parent package, which is `tea_party`. In other words, the package `tea_party` is the parent package of `tea`. So a parent package is a package that contain one or multiple subpackages inside of it.

# Formats of import statements in Python

Import statements in Python are statements used to import functionality from other Python packages or modules, and make them available for you to use in your Python session. In other words, you use import statements to get acess to functions, classes or variables that are declared in other places, outside of your current Python script.

An import statement always contains the `import` keyword, and they come in two styles (or two formats), which are:

- `import x`
- `from x import y`

In the examples above, `x` is a Python package, or a Python module, while `y` might be
, for example, a subpackage, or a function, or a class declared inside of `x`.

## Differences between the two formats of import statements

The main difference between the two formats I mentioned above, is that in the first format (`import x`), you are basically **importing an entire thing**. That is, you are importing an entire Python package or a entire Python module to your Python session. In contrast, in the second format (`from x import y`), you are **importing just a part** (or a small piece) of an existing Python package or Python module to your Python session.

Just as a simple example, if I need to see which date is today, I can use an import statement to import the `date` class from the built-in `datetime` Python package, and use the `date.today()` method to get the answer I need.

```{python}
from datetime import date
print(date.today())
```

In this example, I'm using the second format of import statement (`from x import y`), because we are importing just the `date` class. In other words, instead of importing the entire `datetime` package, we are importing just a piece of it (which is the `date` class) to our session.

So, in essence, we have:

- `import x` = imports the entire package/module (`x`) into your Python session.
- `from x import y` = imports just a small piece (`y` - which can be a subpackage, or a funcion, or a class, etc.) of the package/module (`x`) into your Python session.

# The type of reference you use: absolute imports vs relative imports

The are two types of references you can use in import statements, which are absolute or relative. An absolute reference is probably the style you are more familiar with, because you see it all the time in Python code. As an example, all three import statements below uses an absolute reference to an existing package.

```{python}
# The import statements below are absolute imports,
# because they use absolute references to existing packages.
import datetime
import itertools
import re
```

In contrast, the two statements below uses a relative reference. In these statements, we are importing the function `read_text_file()`, and the classes `Parser` and `Tokenizer` from the local `utils` and `parser` modules.

```{python}
#| eval: false
# The import statements below are relative imports,
# because they use relative references.
from .utils import read_text_file
from .parser import Parser, Tokenizer
```

The notion of "relative imports" (which are import statements that uses relative references) in Python was introduced at [PEP 328](https://peps.python.org/pep-0328/), and are explained in the [Package Relative Imports](https://docs.python.org/3/reference/import.html#package-relative-imports) section of the documentation.

You can see in the above examples that a relative reference uses a dot at the beggining of the module name, like `.utils` and `.parser`. In other words, if you see a reference to something without a dot, like `datetime`, then, it is an absolute reference, but in contrast, a reference that does have a dot that precedes the reference's name, like `.foo`, `.utils` or `.renderer` are examples of relative references.

The core difference between a relative reference and an absolute reference is how Python will search for the reference you asked for. When you use an absolute reference, then, Python will use the Python search path to find the reference you asked for. If you never heard of the Python search path, you can read the @sec-search-path, where I describe this concept.

In constrast, when you use a relative reference, then, Python will search for the reference you asked from inside the folder where your script is located. Relative references become relative paths to the things you are trying to import.

So, the core difference between an import statement that uses an absolute reference from one that uses a relative reference, is the path that Python uses to search the package and module you asked for. The best way to actually understand this difference is with examples. The @sec-context is filled with examples that demonstrates how this search works in each type of reference.

## `import x` is always an absolute import

Everytime you see an import statement in the format `import x` you know it is an absolute import. In other words, when you write an import statement using the format `import x`, then, this import statement will always use the Python search path to find the thing you are trying to import.

This is true because relative imports are not allowed in the format `import x`. That is, statements like `import .utils` are not allowed. Relative references are only used in import statements written in the format `from x import y`.

## `from x import y` might be an absolute import or a relative import

A statement in the format `from x import y` can use both relative and absolute references. You will identify which of the two reference types it uses by looking for the dot character which precedes the reference names in relative references.

That is, a statement like `from datetime import date` uses an absolute reference only because the `datetime` reference does not have a dot before it. If we add a dot, transforming it into `from .datetime import date`, then, the `.datetime` reference becomes a relative reference.



# The context you are in {#sec-context}

You might need to adequate your import statements depeding on the context you are in If you are just developing a few Python scripts, without worring about "packaging" your code, then **you will use absolute imports almost exclusively**.

However, if you are in fact developing a new package, then, you might need to use relative imports in certain situations.

## Search in absolute imports {#sec-absolute-imports}

**For now, let's focus on absolute imports**, and forget that relative imports exists. An absolute import means that you are using an absolute reference, and because of that, Python will search the thing you trying to import using the Python search path.

In essence, the Python search path is composed of two locations, which are:

- the directory that contains the Python module from which you are importing.
- the directory where packages/modules are installed by the package manager in your system.

For example, if you have inside your Python module an statement like `import pandas`, then, Python will search for the `pandas` package/module first, inside of the directory where this Python module from which you are importing lives.

If Python does not find any package/module named as `pandas` in this directory, then, he will search for `pandas` inside the folder in your system where packages and modules are installed by the package manager (`pip install`).


### Be sure that the package is installed in your system

Python will always import the first version it finds of the package/module you requested. However, everytime you use an absolute import, if Python does not find the package/module you asked for in any of the two places I mentioned at @sec-absolute-imports, then, Python will most likely raise a `ModuleNotFoundError` error, like this:

```python
ModuleNotFoundError: No module named 'pandas'
```

This error means that Python could not find the module or package you asked for in your import statement. In this case, it could not find the `pandas` package in my system, using the Python search path.

Most of the times, you get this error message when you are trying to import a package that was supposed to be installed in your system, but unfortunately, it is not installed yet. Because of that, you usually fix this error by effectively installing the package in your system with a `pip install` command:

```bash
pip install pandas
```


## Search in relative imports

When you use relative references, every reference becomes a relative path to the reference you are importing.


# The Python search path {#sec-search-path}

When you import a package in Python, the Python interpreter starts a search process üîç through your computer, to find the specific package (or module) you called in the import statement. Every Python package you use must be installed in your machine. Otherwise, Python will never find it, and, as a consequence, you can not use it.

When you use an absolute reference (or an "absolute import"), the Python interpreter will look for the packages you imported inside a set of pre-defined locations of your computer stored inside the `sys.path` variable. This `sys.path` variable represents the Python search path. So, when you import a package, Python looks for this package inside each one of the directories listed at `sys.path` variable. 

As you can imagine, the Python interpreter look into these directories in a sequential manner. That is, Python looks for the package at the first folder. If it does not find the package you called, then, it looks at the second folder. If it does not find the package again, it looks at the third folder. And goes on and on, until it hits the last folder on the list.

If does not find the package you called at this last folder, Python will automatically raise a `ModuleNotFoundError` error. As you expect, this error means that Python could not find the package you called at any of the directories listed at `sys.path`.

The `sys.path` list usually begins with the path to the directory that contains the Python module from which you are importing. In other words, Python first searchs for the package and the module you asked for inside the same directory that contains your Python module.

Then, it will look inside the folder for DLLs and Lib files in your system. At last, it will search for the package inside the directory where external packages are usually installed in your system. That is the directory that `pip install` uses to install the packages you ask for.

