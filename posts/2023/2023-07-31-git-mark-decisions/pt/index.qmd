---
title: "Melhorando a tomada de decisÃ£o com Git e porque vocÃª deveria se importar"
description: "Esse artigo usa uma caso real que eu e meu time enfrentamos para mostrar como vocÃª pode melhorar a tomada de decisÃ£o de seu time ao rastrear as suas decisÃµes com Git"
image: "./../git-logo.png"
date: "2023-07-31"
---

## IntroduÃ§Ã£o

Na semana passada, eu e minha equipe nos deparamos com uma situaÃ§Ã£o em que precisamos descobrir por que e como ocorreu determinado problema. PrecisÃ¡vamos entender quais decisÃµes levaram a esse problema e por que foram tomadas. Coisas bem normais nÃ©?

Mas entender o que aconteceu sÃ³ foi possÃ­vel para nÃ³s porque rastreamos cada mudanÃ§a e cada decisÃ£o que tomamos com o Git, assinando commits e escrevendo Pull Requests (ou PRs para abreviar). Este artigo usa essa situaÃ§Ã£o do mundo real que enfrentamos para mostrar como o Git e os processos formais para registrar alteraÃ§Ãµes na base de cÃ³digo (como PRs) sÃ£o uma parte crÃ­tica para melhorar a tomada de decisÃµes e entender como suas decisÃµes passadas estÃ£o afetando vocÃª no presente.

ComeÃ§o o artigo descrevendo qual problema ocorreu e, na sequÃªncia, explico quais erros foram cometidos e como o Git nos ajudou a identificar esses erros.


## O pipeline de dados onde ocorreu o problema

O problema ocorreu em um dos muitos pipelines de dados1 que gerenciamos e oferecemos suporte. Esse pipeline de dados especÃ­fico era um tipo de pipeline â€œagregar os dados e enviar os resultados ao clienteâ€. Em detalhes mais tÃ©cnicos, esse pipeline era um arquivo JSON que continha todos os metadados que descreviam o que era esse pipeline, quais etapas ele executava, quais eram as dependÃªncias e configuraÃ§Ãµes de cada tarefa, em que horÃ¡rio especÃ­fico do dia essas tarefas deveriam ser executadas, etc.


A principal etapa (ou tarefa) executada nesse pipeline foi acionar a execuÃ§Ã£o de um notebook Python. Este notebook estava executando as seguintes etapas:

- agrega os dados brutos para obter o total de vendas feitas por canal.
- salva o resultado em um arquivo CSV ou Excel.
- envie este arquivo CSV ou Excel por e-mail para o cliente.


O diagrama a seguir mostra essas etapas de maneira visual:

![Um diagrama que resume o pipeline de dados onde o problema ocorreu](./../diagram-pt.png)


## Qual foi o problema que ocorreu?

Nosso cliente nos notificou dizendo que nÃ£o recebia os arquivos CSV hÃ¡ cerca de uma semana. EntÃ£o comeÃ§amos a procurar por esse pipeline de dados, para ver seus logs de execuÃ§Ã£o. Mas nÃ£o encontramos nada! Tanto o notebook Python quanto o arquivo JSON que descrevia o prÃ³prio pipeline de dados desapareceram! Ã‰ como se nunca tivessem existido.

NÃ£o ter o notebook Python Ã© o mesmo que nÃ£o ter nenhum pipeline. Os arquivos Python e JSON simplesmente desapareceram de nosso repositÃ³rio. Mas o cliente recebeu alguns arquivos algumas semanas atrÃ¡s, portanto, tÃ­nhamos certeza de que esse pipeline existia em algum momento no passado. Mas para onde ele foi? Por que ele desapareceu?


## Investigando os commits

Usamos o Git para armazenar e rastrear quaisquer alteraÃ§Ãµes em todos os nossos pipelines de dados. Em outras palavras, todas as alteraÃ§Ãµes que fazemos nos arquivos JSON que descrevem cada um de nossos pipelines de dados sÃ£o rastreadas pelo Git. Como vocÃª bem sabe, um arquivo simplesmente nÃ£o desaparece de um repositÃ³rio Git. Quando um arquivo Ã© removido de um repositÃ³rio Git, Ã© porque alguÃ©m excluiu intencionalmente o arquivo e fez o commit da alteraÃ§Ã£o no repositÃ³rio.

Como sabÃ­amos que esse pipeline de dados existia em algum momento, comecei a investigar e acompanhar o histÃ³rico de commits. Demorou cerca de 30 minutos para encontrar a confirmaÃ§Ã£o exata que excluiu o pipeline de dados e, oops! O commit foi criado por mim! ExcluÃ­ o pipeline de dados do nosso repositÃ³rio. Okâ€¦ agora Por quÃª? Por que excluÃ­ esse pipeline de dados?

A essa altura, o Git jÃ¡ me ajudou a responder duas questÃµes muito importantes que eram: 1. Quem deletou o pipeline? 2. Quando foi excluÃ­do? Como todo commit que vocÃª cria no Git tem um carimbo de data/hora associado a ele e o nome do autor desse commit, sabÃ­amos naquele momento que fui eu quem excluiu o pipeline, algumas semanas atrÃ¡s.


## Por que tomei essa decisÃ£o?

Mas isso por si sÃ³ nÃ£o responde a outra parte do problema. Ainda precisamos saber por que tomei essa decisÃ£o. Por que excluÃ­ intencionalmente este pipeline? Este Ã© o ponto onde Pull Requests pode nos ajudar.

Sempre que quisermos publicar algumas alteraÃ§Ãµes que fizemos em um pipeline de dados, precisamos documentar essas alteraÃ§Ãµes em um PR. Descrevemos quais mudanÃ§as fizemos e por que as fizemos. Encontrei o PR associado que continha o commit que fiz e, na descriÃ§Ã£o desse PR, descobri o motivo pelo qual excluÃ­ o pipeline.

O pipeline estava constantemente falhando com um erro de â€œnotebook nÃ£o encontradoâ€. Em outras palavras, o pipeline estava tentando acionar a execuÃ§Ã£o do notebook Python que mencionei anteriormente. PorÃ©m o notebook em si nÃ£o foi encontrado, e por conta disso, estava dando esse erro. Isso significa que o pipeline era basicamente inÃºtil, estava criando custos de execuÃ§Ã£o sem entregar nenhum valor. Isso tambÃ©m significa que o notebook Python desapareceu antes que o pipeline fosse excluÃ­do.

EntÃ£o eu apaguei o pipeline. Dessa forma nÃ£o estÃ¡vamos gastando nossos recursos tentando executar algo que sabemos que vai dar erro, e nÃ£o vai dar nenhum valor.


## A outra parte do problema

Ok, agora sabemos porque excluÃ­ o pipeline. Mas isso por si sÃ³ levanta algumas novas questÃµes para nÃ³s. Por que o notebook Python desapareceu? A realidade Ã© queâ€¦ nÃ£o sabÃ­amos por quÃª. Infelizmente, nossos notebooks Python nÃ£o foram hospedados em um repositÃ³rio Git. Isso significa que nÃ£o rastreamos nenhuma alteraÃ§Ã£o feita no notebook.

Para ser justo, nossos notebooks Python sÃ£o hospedados dentro de uma instÃ¢ncia do Databricks e, se vocÃª estiver familiarizado com o Databricks, saberÃ¡ que, na verdade, a plataforma Databricks rastreia (atÃ© certo ponto) todas as alteraÃ§Ãµes feitas no notebook, com o painel RevisÃµes .

EntÃ£o, sim, temos algum nÃ­vel de monitoramento sobre as alteraÃ§Ãµes feitas nesses notebooks. Mas nÃ£o o suficiente para realmente entender por que aquele caderno em particular estava faltando. Em outras palavras, esse painel â€œRevisÃ£oâ€ do Databricks nÃ£o Ã© capaz de rastrear aÃ§Ãµes de remoÃ§Ã£o em notebooks.

SÃ³ conseguimos descobrir o que estava acontecendo na semana seguinte, quando descobrimos que outros notebooks Python tambÃ©m estavam faltando. Era um conjunto de trÃªs notebooks, chamados `Job_ClientX_Opened_Sessions`, `Job_ClientX_Sales_per_Channel` e `Job_ClientX_Opened_Tickets`. Esses trÃªs notebooks estavam localizados na pasta `ClientX`. EntÃ£o, tÃ­nhamos uma estrutura de arquivo como esta:

```
â”œâ”€â”€â”€ğŸ“ ClientX
â”‚    â”œâ”€â”€â”€Job_ClientX_Opened_Sessions.py
â”‚    â”œâ”€â”€â”€Job_ClientX_Sales_per_Channel.py
â”‚    â””â”€â”€â”€Job_ClientX_Opened_Tickets.py
â”‚ 
â”œâ”€â”€â”€ğŸ“ ClientY
â”œâ”€â”€â”€ğŸ“ ClientW
â””â”€â”€â”€ğŸ“ ClientZ
...
```


Nesse dia especÃ­fico, descobrimos nos logs de execuÃ§Ã£o que, por volta das 08:00, esse conjunto de notebooks estava disponÃ­vel, ou seja, eles existiam em nosso ambiente Databricks por volta das 08:00. Mas nesse mesmo dia, quando procuramos novamente Ã s 11:00 por esses mesmos notebooks no ambiente Databricks, nÃ£o os encontramos mais.

SabÃ­amos naquele momento que esses notebooks desapareceram nas Ãºltimas 3 horas. Foi muito recente. Mas um detalhe chamou nossa atenÃ§Ã£o. A pasta `ClientX`, onde deveriam estar esses notebooks, foi preenchida com outros notebooks com nomes semelhantes, como este:


```
â”œâ”€â”€â”€ğŸ“ ClientX
â”‚    â”œâ”€â”€â”€[ClientX] Opened sessions.py
â”‚    â”œâ”€â”€â”€[ClientX] Sales per Channel.py
â”‚    â””â”€â”€â”€[ClientX] Opened Tickets.py
â”‚ 
â”œâ”€â”€â”€ğŸ“ ClientY
â”œâ”€â”€â”€ğŸ“ ClientW
â””â”€â”€â”€ğŸ“ ClientZ
...
```


Isso parece estranho, porque vai contra nossas convenÃ§Ãµes de nomenclatura. Eu e minha equipe nÃ£o nomeamos arquivos assim. EntÃ£o, levantamos a questÃ£o: â€œespere! Acho que alguÃ©m estÃ¡ renomeando esses cadernosâ€. Mais tarde naquele dia, nossas suspeitas foram confirmadas. Um colega de fora de nossa equipe estava renomeando intencionalmente os blocos de anotaÃ§Ãµes do Python que foram publicados no ambiente de produÃ§Ã£o. Por isso nÃ£o estÃ¡vamos encontrando os cadernos, pois seus nomes foram modificados.

A consequÃªncia imediata dessa aÃ§Ã£o de renomeaÃ§Ã£o foi que o link entre os blocos de anotaÃ§Ãµes do Python e os pipelines de dados foi perdido. Ou seja, os pipelines de dados estavam tentando executar esses notebooks, mas nÃ£o encontraram esses notebooks, pois seus nomes originais foram perdidos.



Se usÃ¡ssemos o Git para rastrear todas as alteraÃ§Ãµes feitas nesses notebooks python, terÃ­amos descoberto esse problema muito antes e poderÃ­amos agir para corrigi-lo. Mas o estrago jÃ¡ estava feito. Como prÃ³ximos passos, tivemos que:

- renomeie os notebooks de volta para seus nomes originais;
- remover alguns dos privilÃ©gios de nosso colega no ambiente Databricks;
- aconselhar este colega sobre o que aconteceu e como suas aÃ§Ãµes causaram danos.



## Quais erros foram cometidos?

Abaixo temos a linha do tempo dos eventos importantes que descrevemos:

![Uma timeline dos eventos](./../timeline-pt.png)


Na minha cabeÃ§a, existem pelo menos trÃªs erros que foram cometidos nesta linha do tempo:

- NÃ£o comuniquei a retirada do pipeline adequadamente;
- Nosso colega renomeou um notebook em um ambiente de produÃ§Ã£o;
- NÃ£o usar o Git para rastrear alteraÃ§Ãµes nos notebooks no ambiente de produÃ§Ã£o.


Excluir o pipeline nÃ£o foi um erro. Mas meu erro foi nÃ£o comunicar minha aÃ§Ã£o adequadamente. Quer dizer, comuniquei a remoÃ§Ã£o do pipeline aos meus colegas, mas nÃ£o comuniquei ao meu colega de fora da minha equipe que tambÃ©m estava envolvido com esse cliente especÃ­fico, o mesmo colega que comeÃ§ou a renomear vÃ¡rios notebooks.

Em outras palavras, se eu tivesse comunicado a ele que excluÃ­ o pipeline, provavelmente terÃ­amos um diÃ¡logo semelhante a este:


- Colega: â€œespere! Nosso cliente ainda estÃ¡ usando esse pipeline de dados, por que vocÃª o removeu?â€

- Eu: â€œporque o pipeline nÃ£o estava encontrando o notebookâ€

- Colega: â€œmas porque ele nÃ£o estava achando o notebook?â€

- Eu: â€œbom, o pipeline estÃ¡ procurando um notebook chamado â€˜Xâ€™, mas esse notebook sumiu. NÃ£o existe em nosso ambienteâ€.

- Colega: â€œespere! Eu me lembro deste caderno! Acho que acabei de renomeÃ¡-lo hÃ¡ alguns diasâ€

- Eu: â€œespere! VocÃª renomeou um notebook em produÃ§Ã£o?â€

- Colega: â€œsim, acho que simâ€


Com este diÃ¡logo, provavelmente poderÃ­amos resolver o quebra-cabeÃ§a muito mais rapidamente e corrigir os erros antes que mais danos pudessem ser criados. Portanto, se eu comunicasse a esse colega que excluÃ­ o pipeline, provavelmente atingirÃ­amos o cerne do problema mais rapidamente.

Tudo comeÃ§ou quando nosso colega decidiu renomear um notebook diretamente no ambiente de produÃ§Ã£o sem que soubÃ©ssemos. Isso com certeza foi um erro, mas quem nÃ£o erra as vezes nÃ©? Como descrevemos no artigo, o â€œSistema de revisÃ£oâ€ do Databricks Ã© limitado e nÃ£o acompanhou essa mudanÃ§a tÃ£o importante e, por causa disso, inicialmente nÃ£o tÃ­nhamos ideia do que havia acontecido com o notebook.


Levamos uma semana para realmente descobrir o que estava causando o â€œdesaparecimentoâ€ dos cadernos. Se usÃ¡ssemos o Git para rastrear todas as alteraÃ§Ãµes feitas nos notebooks publicados no ambiente de produÃ§Ã£o, identificarÃ­amos a â€œaÃ§Ã£o de renomeaÃ§Ã£oâ€ muito, muito, muito mais rÃ¡pida. Portanto, nÃ£o usar o Git nesses notebooks tambÃ©m foi um erro.


## Como o Git nos ajudou a resolver o problema

O Git Ã© uma ferramenta extremamente poderosa, e por ter um servidor centralizado que registra todas as mudanÃ§as que vocÃª faz no projeto, vocÃª consegue olhar para o passado, entender quais mudanÃ§as vocÃª fez. VocÃª pode realmente ver a evoluÃ§Ã£o ou a linha do tempo do seu projeto e perceber quantos recursos ou melhorias vocÃª fez no projeto. VocÃª tambÃ©m pode identificar as decisÃµes que tomou no passado. Isso lhe dÃ¡ a capacidade de repensar seu processo de tomada de decisÃ£o.

Um fato que sabÃ­amos desde o inÃ­cio: um pipeline de dados e um notebook Python simplesmente desapareceram de nosso ambiente. Com o Git conseguimos rastrear e entender como, quando e por que o pipeline de dados desapareceu, e conseguimos localizar o pipeline de dados novamente, restaurÃ¡-lo ao seu estado anterior e reenviar os arquivos. Se usÃ¡ssemos o Git nos notebooks, tambÃ©m poderÃ­amos rastrear as operaÃ§Ãµes de renomeaÃ§Ã£o feitas nesses notebooks.

NÃ£o apenas corrigimos o problema, mas tambÃ©m, ao entender o que aconteceu e quais decisÃµes foram tomadas que levaram ao desaparecimento do pipeline de dados, pudemos identificar as falhas em nosso processo de tomada de decisÃ£o. E ao identificar esses problemas, agora podemos resolvÃª-los, para nÃ£o cometermos esses erros novamente.