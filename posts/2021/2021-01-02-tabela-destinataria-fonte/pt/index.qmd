---
title: "Tabela destinat√°ria e tabela fonte"
subtitle: "Uma segunda vis√£o sobre *outer joins*"
description: "Um vis√£o diferente (talvez maluca) sobre como ensinar/explicar *Outer joins* para seus alunos"

categories: ["JOINs", "Teaching"]
date: 2021-01-02
image: "./../featured.png"
projects: ["R_curso"]

aliases: 
    - "./../../../2021-01-02-tabela-destinataria-fonte/pt/"
---


```{css, eval = T, echo = F}
.hljs{
  font-family: 'Inconsolata', monospace;
  font-size: 17px;
}

.hljs.shell{
  font-size: 18px;
}

.hljs-comment{
  font-style: normal;
  color: #222222;
}
```




# Introdu√ß√£o

*Outer joins* s√£o um t√≥pico de simples compreens√£o para a maioria dos alunos. Entretanto, esse artigo prop√µe uma segunda abordagem sobre o tema. Tal abordagem foi constru√≠da durante uma reformula√ß√£o recente do cap√≠tulo "Introdu√ß√£o a base de dados relacionais" do livro [Introdu√ß√£o √† Linguagem R: seus fundamentos e sua pr√°tica](https://pedro-faria.netlify.app/pt/publication/book/introducao_linguagem_r/). O ponto de vista apresentado aqui, busca ser estrito, e utiliza essa rigidez como um mecanismo que facilite a memoriza√ß√£o do aluno sobre os comportamentos de cada tipo de *outer join*.

# Joins possuem sentido e dire√ß√£o

Uma opera√ß√£o de *join* √© nada mais do que uma uni√£o entre duas tabelas. Por outro lado, temos uma outra op√ß√£o de interpreta√ß√£o do resultado dessa opera√ß√£o. De modo que, para produzirmos uma tabela que represente a uni√£o entre duas tabelas, poder√≠amos simplesmente extrair todas as colunas de uma das tabelas, e inser√≠-las na outra tabela.

Por exemplo, suponha que voc√™ possua uma tabela `A`, que cont√©m duas colunas, chamadas `x` e `y`; e uma tabela `B`, que por sua vez, guarda 4 colunas diferentes, denominadas `x`, `z`, `r`, e `t`. Perceba que uma das colunas na tabela `B`, corresponde a mesma coluna `x` que encontramos na tabela `A`.

```{r, include = T}
library(tibble)

A <- tibble(
  x = 1:5,
  y = round(rnorm(5, 2, 1), 2)
)

B <- tibble(
  x = 1:5,
  z = letters[1:5],
  r = c(3.5, 2.1, 1, 5.6, 7.2),
  t = "tzu"
)
```


Se voc√™ deseja unir as tabelas `A` e `B`, voc√™ basicamente deseja criar uma nova tabela, que cont√©m todas as cinco colunas dessas duas tabelas (`x`, `y`, `z`, `r` e `t`). Portanto, poder√≠amos imaginar um processo de *join*, como se estiv√©ssemos transportando todas as colunas da tabela `B`, para dentro da tabela `A`. Dessa maneira, temos a tabela abaixo como resultado:

```{r, include = F}
library(dplyr)
```
```{r, eval = F}
library(dplyr)
```
```{r}
full_join(A, B, by = "x")
```


Com isso, estamos criando a ideia de que **um *join* possui sempre um sentido e uma dire√ß√£o**. Em outras palavras, primeiro, extra√≠mos as colunas da tabela `B`, e em seguida, acrescentamos essas colunas √† tabela `A`. Repare que estamos sempre partindo da tabela `B` em dire√ß√£o a tabela `A`.

```{r}
#| echo: false
knitr::include_graphics("./../direcao.png")
```

# Tabela destinat√°ria e tabela fonte

Por essa perspectiva, podemos interpretar que, em um *join*, estamos trazendo todas as colunas de uma tabela secund√°ria, para dentro de nossa tabela principal (ou a nossa tabela de interesse). Temos a op√ß√£o de chamarmos essas tabelas de: **tabela fonte** (tabela secund√°ria) e **tabela destinat√°ria** (tabela principal). Com isso, temos que um *join* sempre parte da **tabela fonte** em dire√ß√£o √† **tabela destinat√°ria**.

Essa perspectiva faz sentido com a pr√°tica de *joins*. Pois em qualquer an√°lise, n√≥s comumente trabalhamos com uma tabela "principal", ou uma tabela que cont√©m os principais dados que estamos analisando. E quando utilizamos algum *join*, estamos geralmente trazendo colunas de outras tabelas para dentro dessa tabela "principal" (ou tabela "destinat√°ria", segundo essa perspectiva). Por isso, tenha em mente que um *join* sempre parte da **tabela fonte** em dire√ß√£o √† **tabela destinat√°ria**.



# Tipos de *outer join* 

Um *join* natural (*inner join*) usualmente gera uma perda de observa√ß√µes de ambas as tabelas envolvidas no processo. Em contrapartida, um *join* do tipo *outer* (isto √©, um *outer join*), busca delimitar qual das duas tabelas ser√° preservada no resultado. Ou seja, um *outer join* busca manter as linhas de pelo menos uma das tabelas envolvidas, no resultado do *join*.

Temos tr√™s tipos principais de *outer joins*, que s√£o *left join*, *right join* e *full join*. O *full join* √© o mais simples de se compreender, pois ele busca manter todas as linhas de ambas as tabelas empregadas. Logo, mesmo que haja alguma observa√ß√£o n√£o encontrada em uma das tabelas, ela ser√° preservada no produto final da opera√ß√£o.

No entanto, *left join* e *right join* buscam conservar as linhas de apenas uma das tabelas utilizadas no *join*. Nesse ponto, muitos professores diriam algo como: "se temos desejamos aplicar um *join* entre as tabelas `A` e `B`, um *left join* ir√° manter as linhas da tabela `A` e um *right join* vai manter as linhas da tabela `B`". Outros professores ainda tentariam dizer: "*left join* ir√° manter as linhas da tabela √† esquerda, enquanto um *right join* vai manter as linhas da tabela √† direita". 

Por√©m, certa confus√£o pode ser facilmente aplicada em ambas alternativas. Digo, um aluno pode facilmente enfrentar a seguinte quest√£o: "ü§î Uhmm... Eu n√£o me lembro muito bem. Um *left join* mant√©m as linhas da tabela `A`? Ou s√£o as linhas da tabela `B`?"; ou ent√£o, "ü§î Pera! Mas qual das duas tabelas est√° a direita?".

# Conclus√£o

Com isso, segundo a perspectiva adotada nesse artigo, podemos entender que, um *left join* e um *right join* buscam manter as linhas da **tabela destinat√°ria** e da **tabela fonte**, respectivamente. Dessa forma, ao utilizar um *right join* ou um *left join*, voc√™ deve se questionar o seguinte: "Eu quero manter as linhas de minha tabela principal (tabela destinat√°ria)? Ou da tabela secund√°ria (tabela fonte), de onde estou extraindo as novas colunas?". Logo, se voc√™ deseja manter, por exemplo, as linhas de sua tabela principal (tabela destinat√°ria), que √© o que ocorre na maioria das vezes, voc√™ sabe agora que voc√™ precisa utilizar um *left join*.

Em uma representa√ß√£o visual, podemos reproduzir abaixo a imagem inicial desse artigo, que marca as linhas mantidas por cada um desses dois tipos de *join*.

```{r}
#| echo: false
knitr::include_graphics("./../featured.png")
```


