<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.538">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pedro Duarte Faria">
<meta name="dcterms.date" content="2023-11-18">
<meta name="description" content="This past week I had to develop a parser for Python expressions with Python. In this article, I want to use this experience to introduce the subject of parsing to beginners.">

<title>home |&gt; dplyr::glimpse() - Developing a parser for Python with Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7E6XG4WKHE"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-7E6XG4WKHE', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../../../styles.css">
<link rel="stylesheet" href="./../style.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">home |&gt; dplyr::glimpse()</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../../../posts/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../posts/en.html">
 <span class="dropdown-text">Posts in english</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../posts/pt.html">
 <span class="dropdown-text">Posts em português</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-publications" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Publications</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-publications">    
        <li>
    <a class="dropdown-item" href="../../../../publications/index.html">
 <span class="dropdown-text">All publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../publications/en.html">
 <span class="dropdown-text">Publications in English</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../publications/pt.html">
 <span class="dropdown-text">Publicações em Português</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../../open_source_contrib.html"> 
<span class="menu-text">Open source contributions</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../donate.html"> 
<span class="menu-text">Donate or Sponsor Me</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cv" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">CV</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-cv">    
        <li>
    <a class="dropdown-item" href="../../../../files/cv/cv-english.pdf">
 <span class="dropdown-text">CV in English</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../files/cv/cv-portuguese.pdf">
 <span class="dropdown-text">CV em Português</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:pedropark99@gmail.com"> <i class="bi bi-envelope-fill" role="img" aria-label="Email for contact">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pedropark99"> <i class="bi bi-github" role="img" aria-label="Github profile">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://fosstodon.org/web/@pedropark99"> <i class="bi bi-mastodon" role="img" aria-label="Mastodon profile">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://medium.com/@pedropark99"> <i class="bi bi-medium" role="img" aria-label="Medium profile">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/PedroPark9"> <i class="bi bi-twitter" role="img" aria-label="Twitter profile">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/pedro-faria-a68140209/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin profile">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://pedro-faria.netlify.app/index.xml"> <i class="bi bi-rss" role="img" aria-label="RSS feed for Pedro's blog">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Developing a parser for Python with Python</h1>
                  <div>
        <div class="description">
          This past week I had to develop a parser for Python expressions with Python. In this article, I want to use this experience to introduce the subject of parsing to beginners.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Python</div>
                <div class="quarto-category">Parser</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author">Pedro Duarte Faria </p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              Blip
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 18, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-context" id="toc-sec-context" class="nav-link" data-scroll-target="#sec-context"><span class="header-section-number">2</span> Context about what we have to do</a>
  <ul class="collapse">
  <li><a href="#the-quick-and-dirty-approach" id="toc-the-quick-and-dirty-approach" class="nav-link" data-scroll-target="#the-quick-and-dirty-approach"><span class="header-section-number">2.1</span> The quick and dirty approach</a></li>
  <li><a href="#sec-challenge" id="toc-sec-challenge" class="nav-link" data-scroll-target="#sec-challenge"><span class="header-section-number">2.2</span> The size of the challenge</a></li>
  </ul></li>
  <li><a href="#introducing-the-parser" id="toc-introducing-the-parser" class="nav-link" data-scroll-target="#introducing-the-parser"><span class="header-section-number">3</span> Introducing the parser</a>
  <ul class="collapse">
  <li><a href="#what-is-a-parser" id="toc-what-is-a-parser" class="nav-link" data-scroll-target="#what-is-a-parser"><span class="header-section-number">3.1</span> What is a parser?</a></li>
  <li><a href="#sec-kind" id="toc-sec-kind" class="nav-link" data-scroll-target="#sec-kind"><span class="header-section-number">3.2</span> What kind of expressions we want to parse?</a></li>
  <li><a href="#building-the-lexer-or-tokenizer" id="toc-building-the-lexer-or-tokenizer" class="nav-link" data-scroll-target="#building-the-lexer-or-tokenizer"><span class="header-section-number">3.3</span> Building the Lexer (or Tokenizer)</a></li>
  <li><a href="#building-the-actual-parser" id="toc-building-the-actual-parser" class="nav-link" data-scroll-target="#building-the-actual-parser"><span class="header-section-number">3.4</span> Building the actual parser</a>
  <ul class="collapse">
  <li><a href="#the-different-types-of-strategies" id="toc-the-different-types-of-strategies" class="nav-link" data-scroll-target="#the-different-types-of-strategies"><span class="header-section-number">3.4.1</span> The different types of strategies</a></li>
  <li><a href="#the-smaller-components-of-a-parser" id="toc-the-smaller-components-of-a-parser" class="nav-link" data-scroll-target="#the-smaller-components-of-a-parser"><span class="header-section-number">3.4.2</span> The smaller components of a parser</a></li>
  <li><a href="#the-cache-to-store-the-current-parsers-state" id="toc-the-cache-to-store-the-current-parsers-state" class="nav-link" data-scroll-target="#the-cache-to-store-the-current-parsers-state"><span class="header-section-number">3.4.3</span> The cache to store the current parser’s state</a></li>
  <li><a href="#the-main-function-or-entrypoint-for-the-parser" id="toc-the-main-function-or-entrypoint-for-the-parser" class="nav-link" data-scroll-target="#the-main-function-or-entrypoint-for-the-parser"><span class="header-section-number">3.4.4</span> The main function or entrypoint for the parser</a></li>
  <li><a href="#building-the-main-logic-of-the-parser" id="toc-building-the-main-logic-of-the-parser" class="nav-link" data-scroll-target="#building-the-main-logic-of-the-parser"><span class="header-section-number">3.4.5</span> Building the main logic of the parser</a></li>
  <li><a href="#parsing-identifiers" id="toc-parsing-identifiers" class="nav-link" data-scroll-target="#parsing-identifiers"><span class="header-section-number">3.4.6</span> Parsing identifiers</a></li>
  <li><a href="#parsing-strings" id="toc-parsing-strings" class="nav-link" data-scroll-target="#parsing-strings"><span class="header-section-number">3.4.7</span> Parsing strings</a></li>
  <li><a href="#parsing-expressions-inside-formatted-strings" id="toc-parsing-expressions-inside-formatted-strings" class="nav-link" data-scroll-target="#parsing-expressions-inside-formatted-strings"><span class="header-section-number">3.4.8</span> Parsing expressions inside <em>formatted strings</em></a></li>
  <li><a href="#parsing-addition-operations" id="toc-parsing-addition-operations" class="nav-link" data-scroll-target="#parsing-addition-operations"><span class="header-section-number">3.4.9</span> Parsing addition operations</a></li>
  </ul></li>
  <li><a href="#finally-the-parser-is-complete" id="toc-finally-the-parser-is-complete" class="nav-link" data-scroll-target="#finally-the-parser-is-complete"><span class="header-section-number">3.5</span> Finally! The parser is complete!</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Me and my team are currently working in a massive migration (similar to a cloud migration). This migration involves many process, but one of them is to redirect every table reference that we find in more than <strong>130 thousand lines of Python code</strong>.</p>
<p>However, this task proved to be so complex that I had to develop a small parser for Python expressions. In this article, I want to use this experience to introduce the subject of parsing expressions to beginners.</p>
</section>
<section id="sec-context" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Context about what we have to do</h1>
<p>Most of these 130 thousand lines of Python code are <a href="https://spark.apache.org/docs/latest/api/python/index.html"><code>pyspark</code></a> code to extract, transform and load data using the <a href="https://spark.apache.org/">Apache Spark</a> engine.</p>
<p>Let’s consider the following example:</p>
<div id="lst-table" class="python listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;1: Example of pyspark code that we might find in our codebase
</figcaption>
<div aria-describedby="lst-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-table"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="lst-table-1"><a href="#lst-table-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyspark.sql <span class="im">import</span> SparkSession</span>
<span id="lst-table-2"><a href="#lst-table-2" aria-hidden="true" tabindex="-1"></a>spark <span class="op">=</span> SparkSession.builder.getOrCreate()</span>
<span id="lst-table-3"><a href="#lst-table-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-table-4"><a href="#lst-table-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> spark.table(<span class="st">"blip.events"</span>)</span>
<span id="lst-table-5"><a href="#lst-table-5" aria-hidden="true" tabindex="-1"></a>df.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<p>You can see at <a href="#lst-table" class="quarto-xref">Listing&nbsp;1</a> that we have a <code>spark.table()</code> call to access the SQL table <code>blip.events</code>. In other words, we are basically making a <code>SELECT * FROM</code> query over this table. However, in our new infrastructure, all table references will change. As a result, me and my team need to rewrite every table reference that we find across our codebase.</p>
<p>For example, let’s suppose that the new table reference is <code>platform.blipraw.events</code>. This means that I need to alter the above snippet of code to:</p>
<div id="lst-table2" class="python listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;2: Example with the new reference
</figcaption>
<div aria-describedby="lst-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-table2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="lst-table2-1"><a href="#lst-table2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyspark.sql <span class="im">import</span> SparkSession</span>
<span id="lst-table2-2"><a href="#lst-table2-2" aria-hidden="true" tabindex="-1"></a>spark <span class="op">=</span> SparkSession.builder.getOrCreate()</span>
<span id="lst-table2-3"><a href="#lst-table2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-table2-4"><a href="#lst-table2-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> spark.table(<span class="st">"platform.blipraw.events"</span>)</span>
<span id="lst-table2-5"><a href="#lst-table2-5" aria-hidden="true" tabindex="-1"></a>df.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<section id="the-quick-and-dirty-approach" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="the-quick-and-dirty-approach"><span class="header-section-number">2.1</span> The quick and dirty approach</h2>
<p>This does not look so bad, right? I mean, considering the above example, I could just use a simple REGEX (<em>regular expression</em>) to find the places where I have an <code>spark.table()</code> call, capture the reference given as input, alter it to the new reference, and replace the text with the new reference.</p>
<p>This approach would involve some code similar to this:</p>
<div id="c7f1a663" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>notebook_content <span class="op">=</span> <span class="st">'''from pyspark.sql import SparkSession</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">spark = SparkSession.builder.getOrCreate()</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">df = spark.table("blip.events")</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">df.show()</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">'''</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>spark_table_regex <span class="op">=</span> <span class="vs">r'spark[.]table[(][a-zA-Z0-9.\'\"]+[)]'</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>new_table_call <span class="op">=</span> <span class="st">"spark.table(</span><span class="ch">\"</span><span class="st">platform.blipraw.events</span><span class="ch">\"</span><span class="st">)"</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>new_notebook_content <span class="op">=</span> re.sub(spark_table_regex, new_table_call, notebook_content)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_notebook_content)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>from pyspark.sql import SparkSession
spark = SparkSession.builder.getOrCreate()

df = spark.table("platform.blipraw.events")
df.show()
</code></pre>
</div>
</div>
</section>
<section id="sec-challenge" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-challenge"><span class="header-section-number">2.2</span> The size of the challenge</h2>
<p>It would be great if it was that simple, but unfortunately, it is not. What makes this problem so challenging is that the table reference used in <code>spark.table()</code> appears in too many different formats across the 130 thousand lines in our codebase. For example, we might use a <em>formatted string</em> to actually compute the table reference:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>database <span class="op">=</span> <span class="st">"blip"</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>table_name <span class="op">=</span> <span class="st">"events"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> spark.table(<span class="ss">f"</span><span class="sc">{</span>database<span class="sc">}</span><span class="ss">.</span><span class="sc">{</span>table_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Or maybe, we call a variable that contains the computed reference:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>table_ref <span class="op">=</span> database <span class="op">+</span> <span class="st">'.'</span> <span class="op">+</span> table_name</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> spark.table(table_ref)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These two examples demonstrates that too much variation exists in the use of a table reference. So much variation, that using multiple REGEX’s to solve this problem would be impractical, and probably too much complex.</p>
<p>Here is where the parser comes into place.</p>
</section>
</section>
<section id="introducing-the-parser" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Introducing the parser</h1>
<section id="what-is-a-parser" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="what-is-a-parser"><span class="header-section-number">3.1</span> What is a parser?</h2>
<p>Parsers (or the process of parsing expressions) are core components of every existing compiler, like <code>gcc</code> or <code>rustc</code>, as well as the R and Python compilers. In essence, a parser is a piece of software that analyzes expressions following the rules of a grammar. A parser is the main part of compilers responsible for analyzing and comprehend the structure of your source code.</p>
<p>The process of parsing is usually made in two steps, which are: 1) breaking (or “splitting”) the input expression into smaller pieces, building a list of tokens, or a list of small components; 2) analyzing this sequence of tokens to build a tree that is equivalent to the input expression. The first step above is usually made by a component called <em>lexer</em> or <em>tokenizer</em> (both names are commom to find), and the second step is made by the parser itself.</p>
<p>Basically, the process of parsing takes a string (which contains the expression, or the source code your want to parse) as input. Then, the lexer (or tokenizer) breaks the input string into smaller pieces, which are usually called <em>tokens</em>. Then, the parser receives this stream of tokens produced by the tokenizer as input, and starts to analyze this sequence of tokens, to understand the structure of the input expression (or source code). As output, the parser produces a tree that is equivalent to the input expression, which is usually called <em>abstract syntax tree</em> (or AST for short). <a href="#fig-parser-pic" class="quarto-xref">Figure&nbsp;1</a> below exposes this process.</p>
<div id="fig-parser-pic" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-parser-pic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../parser-pic.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-parser-pic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The process of parsing
</figcaption>
</figure>
</div>
<p>So the process of parsing takes an expression as input, and builds a tree that is equivalent to that expression as output. This process of parsing is always one of the first operations that a compiler performs.</p>
<p>Because trees are a much more suitable and efficient data structure for the different tasks a compiler performs such as: type and syntax checking, evaluating the result of expressions and assignments, or compiling the input tree into machine code to be executed.</p>
<p>Probably, the most important data structures for every compiler are trees and stacks.</p>
</section>
<section id="sec-kind" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-kind"><span class="header-section-number">3.2</span> What kind of expressions we want to parse?</h2>
<p>Just to be clear, we neither need (or want) to develop a complete parser capable of parsing every expression in the Python language. That would be a much larger task, that would involve a great amount of effort. We just want to build a small parser capable of parsing a very small and specific subset of Python expressions.</p>
<p>We are particularly interested in the expressions that are related to the table references that we find in our codebase. We already showed examples of these expressions at <a href="#sec-context" class="quarto-xref">Section&nbsp;2</a> and <a href="#sec-challenge" class="quarto-xref">Section&nbsp;2.2</a>.</p>
<p>But just to state clearly, we want to build a parser capable of parsing:</p>
<ol type="1">
<li>expressions that involves only string constants (other types of constants or structures such as lists, integers, booleans are not important for us, so let’s ignore them). Example: <code>"platform.blipraw.events"</code>.</li>
<li>expressions that concatenate strings with the plus operator. Example: <code>"blip" + "." + "events"</code>.</li>
<li>expressions that contains identifiers (that is, variable names). Example: <code>database + "." + table_name</code>.</li>
<li>formatted strings which contain expressions that fit the above cases. Example: <code>f"{database}.{table_name}"</code>.</li>
</ol>
<p>Lets store these examples of expressions inside a list that we can easily access:</p>
<div id="91604672" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>EXPRESSION_EXAMPLES <span class="op">=</span> [</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"'platform.blipraw.events'"</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'"blip" + "." + "events"'</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"database + </span><span class="ch">\"</span><span class="st">.</span><span class="ch">\"</span><span class="st"> + table_name"</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'f"</span><span class="sc">{database}</span><span class="st">.</span><span class="sc">{table_name}</span><span class="st">"'</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="building-the-lexer-or-tokenizer" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="building-the-lexer-or-tokenizer"><span class="header-section-number">3.3</span> Building the Lexer (or Tokenizer)</h2>
<p>Lets begin by building a lexer (or tokenizer) for our parser. Just be aware that, from now on, I will use the term tokenizer instead of lexer (this is just a personal preference).</p>
<p>But how can we split our input string into small pieces? Well, there are different approaches to do this. However, one particular approach that fit’s perfectly our example here is to iterate through the characters of our input string, and look for single characters that represent “elegible break points”, or points where we can split the string.</p>
<p>This approach is probably the easiest of all to implement, and it fit’s perfectly our example here because we are interested in parsing just a very small subset of simple Python expressions. If we wanted to parse more complex expressions, then, it would probably be better to use another approach to break the input string.</p>
<p>So, the tokenizer will iterate through each character in the input string, and will mark any place that contains a single character the we interpret as an elegible place to break the string. Considering the type of expressions we stated at <a href="#sec-kind" class="quarto-xref">Section&nbsp;3.2</a>, the characters <code>"</code>, <code>'</code>, <code>+</code>, <code>{</code>, <code>}</code> are good candidates for “elegible break points”. Also, the character <code>f</code> is important for identifying formatted strings, as a consequence, he is also a good candidate.</p>
<p>Let’s consider the following tokenizer:</p>
<div id="lst-tokenizer" class="python listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-tokenizer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;3: The function that represents our tokenizer
</figcaption>
<div aria-describedby="lst-tokenizer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-tokenizer"><pre class="sourceCode code-annotation-code python code-with-copy"><code class="sourceCode python"><span id="lst-tokenizer-1"><a href="#lst-tokenizer-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List</span>
<span id="lst-tokenizer-2"><a href="#lst-tokenizer-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="lst-tokenizer-3"><a href="#lst-tokenizer-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-tokenizer-4"><a href="#lst-tokenizer-4" aria-hidden="true" tabindex="-1"></a>is_not_blank <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">!=</span> <span class="st">""</span> <span class="kw">and</span> <span class="kw">not</span> re.search(<span class="vs">r"^ +$"</span>, x)</span>
<span id="lst-tokenizer-5"><a href="#lst-tokenizer-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tokenizer(input_string: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="lst-tokenizer-6"><a href="#lst-tokenizer-6" aria-hidden="true" tabindex="-1"></a>    candidates <span class="op">=</span> [<span class="st">"'"</span>, <span class="st">'"'</span>, <span class="st">'+'</span>, <span class="st">'{'</span>, <span class="st">'}'</span>]</span>
<span id="lst-tokenizer-7"><a href="#lst-tokenizer-7" aria-hidden="true" tabindex="-1"></a>    break_points <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="lst-tokenizer-8"><a href="#lst-tokenizer-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(input_string)):</span>
<span id="lst-tokenizer-9"><a href="#lst-tokenizer-9" aria-hidden="true" tabindex="-1"></a>        current_char <span class="op">=</span> input_string[i]</span>
<span id="lst-tokenizer-10"><a href="#lst-tokenizer-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_char <span class="kw">in</span> candidates:</span>
<span id="lst-tokenizer-11"><a href="#lst-tokenizer-11" aria-hidden="true" tabindex="-1"></a>            break_points.append(i)</span>
<span id="lst-tokenizer-12"><a href="#lst-tokenizer-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_char <span class="op">==</span> <span class="st">"f"</span> <span class="kw">and</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">&lt;</span> <span class="bu">len</span>(input_string):</span>
<span id="lst-tokenizer-13"><a href="#lst-tokenizer-13" aria-hidden="true" tabindex="-1"></a>            next_char <span class="op">=</span> input_string[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="lst-tokenizer-14"><a href="#lst-tokenizer-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> next_char <span class="kw">in</span> [<span class="st">'"'</span>, <span class="st">"'"</span>]:</span>
<span id="lst-tokenizer-15"><a href="#lst-tokenizer-15" aria-hidden="true" tabindex="-1"></a>                break_points.append(i)</span>
<span id="lst-tokenizer-16"><a href="#lst-tokenizer-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-tokenizer-17"><a href="#lst-tokenizer-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(break_points) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="lst-tokenizer-18"><a href="#lst-tokenizer-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [input_string]</span>
<span id="lst-tokenizer-19"><a href="#lst-tokenizer-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-tokenizer-20"><a href="#lst-tokenizer-20" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="lst-tokenizer-21"><a href="#lst-tokenizer-21" aria-hidden="true" tabindex="-1"></a>    last_index <span class="op">=</span> <span class="dv">0</span></span>
<span id="lst-tokenizer-22"><a href="#lst-tokenizer-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index <span class="kw">in</span> break_points:</span>
<span id="lst-tokenizer-23"><a href="#lst-tokenizer-23" aria-hidden="true" tabindex="-1"></a>        tokens.append(input_string[last_index:index])</span>
<span id="lst-tokenizer-24"><a href="#lst-tokenizer-24" aria-hidden="true" tabindex="-1"></a>        tokens.append(input_string[index:(index<span class="op">+</span><span class="dv">1</span>)])</span>
<span id="lst-tokenizer-25"><a href="#lst-tokenizer-25" aria-hidden="true" tabindex="-1"></a>        last_index <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span></span>
<span id="lst-tokenizer-26"><a href="#lst-tokenizer-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst-tokenizer-27"><a href="#lst-tokenizer-27" aria-hidden="true" tabindex="-1"></a>    tokens.append(input_string[last_index:])</span>
<span id="lst-tokenizer-28"><a href="#lst-tokenizer-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">filter</span>(is_not_blank, tokens))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
<ol type="1">
<li><p>If current character is <code>f</code> check if the next character is the beginning of a string (characters <code>"</code> and <code>'</code>), if it is the beginning of a string, then, it is a formatted string and should be included in the “break points”. If the next character is not the beginning of a string, then, we should not consider it as an elegible breakpoint, because it probably is just a letter “f” inside a variable name, such as <code>platform_database</code>.</p></li>
<li><p>If no break point position was found, then, the input expression is likely an expression with a single component. For example, a single string constant (e.g.&nbsp;<code>"blip.events"</code>) or a single variable name (<code>events_table</code>). In this case, the tokenizer should return this single component itself as the only token present in the input string.</p></li>
<li><p>Every iteration of the loop generates two different tokens, which are: 1) a token with the part of the string from the previous break point index until the current elegible break point index; 2) and another token containing the single character that identifies the current elegible breakpoint. For example, the text <code>database"</code> will generate the break point index <code>8</code>, so, in the first iteration of the loop, the tokens <code>'database'</code> and <code>'"'</code> will be generated.</p></li>
<li><p>Empty tokens (i.e.&nbsp;tokens that are empty strings, or, that contains only spaces) can be generated during the process. So we use <code>filter()</code> with a <code>lambda</code> function to eliminate them from the output.</p></li>
</ol>
<p>This <code>tokenizer()</code> function generates a list of tokens to be analyzed by the parser:</p>
<div id="3087c5da" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> example <span class="kw">in</span> EXPRESSION_EXAMPLES:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> tokenizer(example)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"================================================================"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"  * Input expression: "</span>, example)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"  * Tokens produced: "</span>, tokens)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>================================================================
  * Input expression:  'platform.blipraw.events'
  * Tokens produced:  ["'", 'platform.blipraw.events', "'"]
================================================================
  * Input expression:  "blip" + "." + "events"
  * Tokens produced:  ['"', 'blip', '"', '+', '"', '.', '"', '+', '"', 'events', '"']
================================================================
  * Input expression:  database + "." + table_name
  * Tokens produced:  ['database ', '+', '"', '.', '"', '+', ' table_name']
================================================================
  * Input expression:  f"{database}.{table_name}"
  * Tokens produced:  ['f', '"', '{', 'database', '}', '.', '{', 'table_name', '}', '"']</code></pre>
</div>
</div>
</section>
<section id="building-the-actual-parser" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="building-the-actual-parser"><span class="header-section-number">3.4</span> Building the actual parser</h2>
<p>Building the actual parser is definitely the hard part. Because a parser usually involves: 1) having a variable to store the current state of the parser, or, the current state of the AST; 2) and also some level of recursion to traverse the AST, or to decide which move or production rule should be applied. Making these two components working well together can be difficult depending on how you implement it.</p>
<section id="the-different-types-of-strategies" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="the-different-types-of-strategies"><span class="header-section-number">3.4.1</span> The different types of strategies</h3>
<p>Remember, the end goal of a parser, is to build an abstract syntax tree (AST) by analizing a sequence of tokens. There are different strategies to build this tree, and they are usually divided into two categories: 1) <em>top-down</em>. These are strategies that builds the tree from the root, and work they way to the bottom of the tree, which contains the “leaves of the tree”; 2) <em>bottom-up</em> (the inverse). These are strategies which starts to build the tree from the leaves, and work they way up until it hits the root of the tree.</p>
<p>In the subject of parsing, <em>top-down</em> strategies are the most popular (notice that this does not mean that <em>bottom-up</em> strategies are bad or not commom). The most popular strategy of all is the <em>Recursive Descent</em>, which is a <em>top-down</em> strategy. But I will not describe these strategy here, specially to avoid all the technical jargon that they bring with them. Anyway, just be aware that there are different strategies out there, and that in this article I’m only presenting one of them.</p>
</section>
<section id="the-smaller-components-of-a-parser" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="the-smaller-components-of-a-parser"><span class="header-section-number">3.4.2</span> The smaller components of a parser</h3>
<p>Every parser usually involves two smaller components: 1) a cache that holds the current state of the parser. This cache stores variables that are essential to the parsing process, such as the current state of the AST builded by the parser; 2) and a control (or “decision-making”) mechanism, which is usually a collection of methods or functions that decides which move the parser should make considering it’s current state (<span class="citation" data-cites="gries2008">Gries and Schneider (<a href="#ref-gries2008" role="doc-biblioref">2008</a>)</span>).</p>
<p>Some degree of recursion is found very frequently on some of these methods or functions that decides which move the parser should make. Although this recursion is not something mandatory, because there are some available strategies to build the AST that do not involves any recursion at all.</p>
</section>
<section id="the-cache-to-store-the-current-parsers-state" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="the-cache-to-store-the-current-parsers-state"><span class="header-section-number">3.4.3</span> The cache to store the current parser’s state</h3>
<p>Lets build a Python class to represent the cache of the parser. This <code>ParserCache</code> class will be responsible for storing all variables that are vital to the parsing process. These variables are:</p>
<ul>
<li><code>ast</code>: stores the current state of the AST.</li>
<li><code>tokens</code>: stores the full sequence of tokens that the parser needs to analyze.</li>
<li><code>index</code>: stores the index on the sequence of tokens that the parser is currently on.</li>
<li><code>token</code>: stores a copy of the current token that the parser is analyzing at the moment.</li>
</ul>
<p>It is not really vital to have the <code>token</code> variable, because we could easily access the current token by using <code>tokens[index]</code>. But… having a variable called <code>token</code> is easier to type, and it makes most of the parser’s code more readable, so, it is woth it.</p>
<p>While the parser is analyzing the sequence of tokens stored at the <code>tokens</code> variable, he will slowly grow (or complete) the AST, by replacing and adding elements to the <code>ast</code> variable. At the end, when the parser finishs the parsing process, the <code>ast</code> variable will store the complete AST that is equivalent to the input expression.</p>
<p>You can see below at the <code>__init__()</code> method that to initialize a new object of class <code>ParserCache</code>, you need to give the sequence of tokens to analyze as input. After that, all variables of the class are initialized, and you can start to use the two methods of the class, which are <code>len()</code>, <code>current_token()</code> and <code>next_token()</code>. The <code>len()</code> method returns the length of the tokens sequence that the parser is analyzing, <code>current_token()</code> method returns the current token that the parser is analyzing at the moment, and the <code>next_token()</code> method will effectively advance the parser to the next token in the sequence.</p>
<div id="9f13e297" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParserCache:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Class that represents a cache to store the current state of the parser.'''</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, tokens: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ast <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.tokens <span class="op">=</span> tokens</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(tokens) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.token <span class="op">=</span> tokens[<span class="va">self</span>.index]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.token <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">len</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.tokens)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> current_token(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.token</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> current_index(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.index</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> next_token(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.index <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.tokens):</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.token <span class="op">=</span> <span class="va">self</span>.tokens[<span class="va">self</span>.index]</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="the-main-function-or-entrypoint-for-the-parser" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="the-main-function-or-entrypoint-for-the-parser"><span class="header-section-number">3.4.4</span> The main function or entrypoint for the parser</h3>
<p>We need a main function for the parser, and that is the <code>parse()</code> function. In other words, this is the public API or the main entrypoint of the parser. That is the function that we should use to effectively parse any input and get the resulting AST.</p>
<p>You can see below that all of this function does is: get the input string; generate the tokens with <code>tokenizer()</code>; initialize the parser’s cache with these tokens; and then, it calls a private function called <code>_parse_input()</code> to initiate the parsing process.</p>
<p>Once <code>_parse_input()</code> is done with the parsing process, <code>parse()</code> gets the parsing results and simply return the complete AST produced, which is stored in the <code>ast</code> variable of the parser’s cache.</p>
<div id="78ce9e68" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(input_string: <span class="bu">str</span>) <span class="op">-&gt;</span> List[Dict[<span class="bu">str</span>, Any]]:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> tokenizer(input_string)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    parser_cache <span class="op">=</span> ParserCache(tokens)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    parsing_result <span class="op">=</span> _parse_input(parser_cache)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parsing_result.ast</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="building-the-main-logic-of-the-parser" class="level3" data-number="3.4.5">
<h3 data-number="3.4.5" class="anchored" data-anchor-id="building-the-main-logic-of-the-parser"><span class="header-section-number">3.4.5</span> Building the main logic of the parser</h3>
<p>The true magic starts with the private function <code>_parse_input()</code>. Basically, <code>_parse_input()</code> starts by looking at the current of token in the sequence that is being analyzed.</p>
<p>If this current token represents the beginning of a string (characters <code>"</code> and <code>'</code>), <code>_parse_string()</code> is called to effectively parse the next tokens in the sequence, which (very likely) are the contents of that string. If this current token is <code>f</code>, then, we have the beginning of a formatted string, so we just skip this <code>f</code> token with <code>parse_cache.next_token()</code>, and call <code>_parse_string()</code> to parse the formatted string. But if this token is a plus sign, then, he will call <code>_parse_addition()</code> to parse this token. If the current token is neither the beginning of a string or a plus sign, then, <code>_parse_input()</code> will assume that this current token is an identifier, and he will call <code>_parse_identifier()</code> to parse it.</p>
<p>Notice that all of these three parsing functions (<code>_parse_string()</code>, <code>_parse_addition()</code> and <code>_parse_identifier()</code>) returns the <code>ParserCache</code> object back as output. In other words, these functions receives the parser cache as input, they use this cache to parse the current token, and they add new elements (or replace the existing ones) to the AST, which is stored inside this cache object. Once they finished their businesses, they simply return this cache back as their output.</p>
<p>After we know that we parsed the current token, then, we ask the parser to advance to the next token, with <code>next_token()</code> method. Then, we check if there is really a next token in the sequence to parse/analyze, by checking if the current index is greater than the number of tokens in the sequence.</p>
<p>If there are still some remaining tokens in the sequence to analyze, then, <code>_parse_input()</code> will call itself recursively to parse the remaining tokens in the sequence. However, if there is not remaining tokens to analyze anymore, then, the function finally returns the parser cache (which contains the complete AST inside of the <code>ast</code> variable) as output.</p>
<div id="1b47fdea" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="annotated-cell-8"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-8-1"><a href="#annotated-cell-8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_input(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-8-2" class="code-annotation-target"><a href="#annotated-cell-8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parser_cache.<span class="bu">len</span>() <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-8-3"><a href="#annotated-cell-8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parser_cache</span>
<span id="annotated-cell-8-4"><a href="#annotated-cell-8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-8-5"><a href="#annotated-cell-8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parser_cache.current_token() <span class="kw">in</span> [<span class="st">'"'</span>, <span class="st">"'"</span>]:</span>
<span id="annotated-cell-8-6"><a href="#annotated-cell-8-6" aria-hidden="true" tabindex="-1"></a>        parser_cache <span class="op">=</span> _parse_string(parser_cache)</span>
<span id="annotated-cell-8-7"><a href="#annotated-cell-8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> parser_cache.current_token() <span class="op">==</span> <span class="st">'f'</span>:</span>
<span id="annotated-cell-8-8"><a href="#annotated-cell-8-8" aria-hidden="true" tabindex="-1"></a>        parser_cache.next_token()</span>
<span id="annotated-cell-8-9"><a href="#annotated-cell-8-9" aria-hidden="true" tabindex="-1"></a>        parser_cache <span class="op">=</span> _parse_string(parser_cache)</span>
<span id="annotated-cell-8-10"><a href="#annotated-cell-8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> parser_cache.current_token() <span class="op">==</span> <span class="st">'+'</span>:</span>
<span id="annotated-cell-8-11"><a href="#annotated-cell-8-11" aria-hidden="true" tabindex="-1"></a>        parser_cache <span class="op">=</span> _parse_addition(parser_cache)</span>
<span id="annotated-cell-8-12"><a href="#annotated-cell-8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-8-13"><a href="#annotated-cell-8-13" aria-hidden="true" tabindex="-1"></a>        parser_cache <span class="op">=</span> _parse_identifier(parser_cache)</span>
<span id="annotated-cell-8-14"><a href="#annotated-cell-8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-8-15"><a href="#annotated-cell-8-15" aria-hidden="true" tabindex="-1"></a>    parser_cache.next_token()</span>
<span id="annotated-cell-8-16"><a href="#annotated-cell-8-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parser_cache.current_index() <span class="op">&lt;=</span> parser_cache.<span class="bu">len</span>() <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="annotated-cell-8-17"><a href="#annotated-cell-8-17" aria-hidden="true" tabindex="-1"></a>        parser_cache <span class="op">=</span> _parse_input(parser_cache)</span>
<span id="annotated-cell-8-18"><a href="#annotated-cell-8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-8-19"><a href="#annotated-cell-8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-8" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="2" data-code-annotation="1">If the sequence of tokens is empty, then, we have no tokens to analyze, and the function should simply return right away.</span>
</dd>
</dl>
</div>
</div>
<p>Yes! I know what you are thinking. If the current token is neither the beginning of a string or a plus sign, then, he could be anything else. For example, he could be the beginning of a function call, or, a logic comparison, or it could be the beginning of an assignment expression. Anyway, it could be many things! So in theory, it is not safe to simply assume that it is an identifier.</p>
<p>However, you need to remember what we proposed at <a href="#sec-kind" class="quarto-xref">Section&nbsp;3.2</a>. We want to parse only a very small subset of Python expressions. We do not want (or care) to parse other kinds of expressions. If you look at the expressions examples that fitted the description in <a href="#sec-kind" class="quarto-xref">Section&nbsp;3.2</a>, you will see that the only components that appears in those expressions are identifiers, additions and string constants.</p>
<p>That is why we care only about these components. That is why, <strong>for this specific case</strong>, it is safe to assume that the last option has to be an identifier.</p>
</section>
<section id="parsing-identifiers" class="level3" data-number="3.4.6">
<h3 data-number="3.4.6" class="anchored" data-anchor-id="parsing-identifiers"><span class="header-section-number">3.4.6</span> Parsing identifiers</h3>
<p>Lets begin by discussing what the <code>_parse_identifier()</code> function should do. Because parsing an identifier component is by far the simplest of all three components. I mean… how would you parse an identifier? To answer this question, is probably best to think what an identifier is.</p>
<p>Well, an identifier is just a name to a variable, right? So, the value of an identifier object should be the identifier itself! In other words, the name of the variable is the identifier itself. So why not just simply add to the AST an object of type <code>IDENTIFIER</code> and the value of that object being the current token which is the identifier (or the variable name) itself? Right? That should be sufficient.</p>
<p>So we have the following body for <code>_parse_identifier()</code>:</p>
<div id="2895ea2c" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_identifier(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    parser_cache.ast.append({</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'IDENTIFIER'</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'value'</span>: <span class="bu">str</span>(parser_cache.current_token())</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="parsing-strings" class="level3" data-number="3.4.7">
<h3 data-number="3.4.7" class="anchored" data-anchor-id="parsing-strings"><span class="header-section-number">3.4.7</span> Parsing strings</h3>
<p>Now, things get worse when it is time to parse strings. Not because strings are complicated, but because we need to account for <em>formatted strings</em>. In other words, the string that we analyzing might contain expressions inside of it. And if it does have them, we need to parse these expressions in a separate process.</p>
<p>However, if you come back and look at the body of <code>_parse_input()</code> you will see that we call <code>_parse_string()</code> right after we encounter a <code>"</code> or <code>'</code> character. But we do not need to parse this single character exactly. We just know that these characters delimit the beginning of a string, so everything that goes after it should be tokens that together composes the actual content of the string. That is why, we start <code>_parse_string()</code> by calling the <code>next_token()</code> method, to skip this <code>"</code> or <code>'</code> character that we are not particularly interested in.</p>
<p>Now, after that, the next tokens in the sequence will very likely represent the contents of this string that we are currently parsing. So all we need to do, is to use a loop to iterate trough these next tokens and stop (or break) the loop in the moment that we hit a token that contains the <code>"</code> or <code>'</code> character, because these tokens will represent the end of the string.</p>
<p>We could use a stack to accumulate the tokens that represents the contents of the string while we are looping, and then, we analyze these tokens separately after we break the loop. Then, we could simply append to the AST a new object of type <code>STRING</code> containing this stack with all of the components of this string element. It would be a fair strategy. But it would also make the parsing of subexpressions inside of formatted strings harder.</p>
<p>As a result, I decided to opt for a placeholder strategy. Before we start to loop through the sequence of tokens that represents the contents of the string, we add a placeholder at the top level of the AST. At each iteration of the <code>while</code> loop we update the <code>value</code> field of this placeholder by adding the current token to it. By doing this, at the end of the <code>while</code> loop we will have a string object at the top of the AST, and its <code>value</code> field will contain the full/complete list of contents of that string.</p>
<p>Now… if we do find a opening bracket (<code>{</code>) inside the string, that likely means that the current string that we are analyzing now is a formatted string, and whatever sequence of tokens that is right after this opening bracket, they are a new expression to be parsed. That is why we call the <code>_parse_formatted_string()</code> in case we do find an opening bracket inside the string.</p>
<div id="3ef7343b" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="annotated-cell-10"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-10-1"><a href="#annotated-cell-10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_string(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-10" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-10-2" class="code-annotation-target"><a href="#annotated-cell-10-2" aria-hidden="true" tabindex="-1"></a>    char_that_opens_the_string <span class="op">=</span> parser_cache.current_token()</span>
<span id="annotated-cell-10-3"><a href="#annotated-cell-10-3" aria-hidden="true" tabindex="-1"></a>    parser_cache.next_token()</span>
<span id="annotated-cell-10-4"><a href="#annotated-cell-10-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add a placeholder in the top of the AST</span></span>
<span id="annotated-cell-10-5"><a href="#annotated-cell-10-5" aria-hidden="true" tabindex="-1"></a>    parser_cache.ast.append({</span>
<span id="annotated-cell-10-6"><a href="#annotated-cell-10-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'STRING'</span>,</span>
<span id="annotated-cell-10-7"><a href="#annotated-cell-10-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'value'</span>: <span class="bu">list</span>()</span>
<span id="annotated-cell-10-8"><a href="#annotated-cell-10-8" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="annotated-cell-10-9"><a href="#annotated-cell-10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-10-10"><a href="#annotated-cell-10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> parser_cache.current_index() <span class="op">&lt;</span> parser_cache.<span class="bu">len</span>() <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="annotated-cell-10-11"><a href="#annotated-cell-10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parser_cache.current_token() <span class="op">==</span> char_that_opens_the_string:</span>
<span id="annotated-cell-10-12"><a href="#annotated-cell-10-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="annotated-cell-10-13"><a href="#annotated-cell-10-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parser_cache.current_token() <span class="op">==</span> <span class="st">'{'</span>:</span>
<span id="annotated-cell-10-14"><a href="#annotated-cell-10-14" aria-hidden="true" tabindex="-1"></a>            parser_cache.next_token()</span>
<span id="annotated-cell-10-15"><a href="#annotated-cell-10-15" aria-hidden="true" tabindex="-1"></a>            parser_cache <span class="op">=</span> _parse_formatted_string(parser_cache)</span>
<span id="annotated-cell-10-16"><a href="#annotated-cell-10-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="annotated-cell-10-17"><a href="#annotated-cell-10-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="annotated-cell-10-18"><a href="#annotated-cell-10-18" aria-hidden="true" tabindex="-1"></a>        elem_ref <span class="op">=</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="annotated-cell-10-19"><a href="#annotated-cell-10-19" aria-hidden="true" tabindex="-1"></a>        elem_ref[<span class="st">'value'</span>].append(parser_cache.current_token())</span>
<span id="annotated-cell-10-20"><a href="#annotated-cell-10-20" aria-hidden="true" tabindex="-1"></a>        parser_cache.next_token()</span>
<span id="annotated-cell-10-21"><a href="#annotated-cell-10-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-10-22"><a href="#annotated-cell-10-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-10" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-10" data-code-lines="2" data-code-annotation="1">We copy the character (<code>'</code> or <code>"</code>) that openned the string that we are analyzing now, because then, we can search for a new occurence of this same character in the tokens sequence to detect the end of the string.</span>
</dd>
</dl>
</div>
</div>
<!-- 2. We add a placeholder at the top level of the AST. At each iteration of the `while` loop we update the `value` field of this placeholder by adding the current token to it. By doing this, at the end of the `while` loop we will have a string object at the top of the AST, and its `value` field will contain the full/complete list of contents of that string. -->
</section>
<section id="parsing-expressions-inside-formatted-strings" class="level3" data-number="3.4.8">
<h3 data-number="3.4.8" class="anchored" data-anchor-id="parsing-expressions-inside-formatted-strings"><span class="header-section-number">3.4.8</span> Parsing expressions inside <em>formatted strings</em></h3>
<p>We call <code>_parse_formatted_string()</code> if we find a <code>{</code> character inside sequence of tokens that are inside a string. Inside the pair of brackets (<code>{}</code>) we will always have an expression. And because this is a new expression, we need to parse it too, in a separate process.</p>
<p>First, we use a loop and a stack object to accumulate all the tokens in the sequence that are inside of the pair of brackets (<code>{}</code>). This way, we have inside the stack object all the tokens that represents the subexpression that is inside of the brackets that we need to parse.</p>
<div id="68a31cfe" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="annotated-cell-11"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-11-1"><a href="#annotated-cell-11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_formatted_string(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<span id="annotated-cell-11-2"><a href="#annotated-cell-11-2" aria-hidden="true" tabindex="-1"></a>    stack <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="annotated-cell-11-3"><a href="#annotated-cell-11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> parser_cache.current_index() <span class="op">&lt;</span> parser_cache.<span class="bu">len</span>() <span class="op">-</span> <span class="dv">1</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-11" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-11-4" class="code-annotation-target"><a href="#annotated-cell-11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parser_cache.current_token() <span class="op">==</span> <span class="st">'}'</span>:</span>
<span id="annotated-cell-11-5"><a href="#annotated-cell-11-5" aria-hidden="true" tabindex="-1"></a>            parser_cache.next_token()</span>
<span id="annotated-cell-11-6"><a href="#annotated-cell-11-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="annotated-cell-11-7"><a href="#annotated-cell-11-7" aria-hidden="true" tabindex="-1"></a>        stack.append(parser_cache.current_token())</span>
<span id="annotated-cell-11-8"><a href="#annotated-cell-11-8" aria-hidden="true" tabindex="-1"></a>        parser_cache.next_token()</span>
<span id="annotated-cell-11-9"><a href="#annotated-cell-11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-11-10"><a href="#annotated-cell-11-10" aria-hidden="true" tabindex="-1"></a>    parsed_subexpression <span class="op">=</span> ParserCache(stack)</span>
<span id="annotated-cell-11-11"><a href="#annotated-cell-11-11" aria-hidden="true" tabindex="-1"></a>    parsed_subexpression <span class="op">=</span> _parse_input(parsed_subexpression)</span>
<span id="annotated-cell-11-12"><a href="#annotated-cell-11-12" aria-hidden="true" tabindex="-1"></a>    elem_ref <span class="op">=</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="annotated-cell-11-13"><a href="#annotated-cell-11-13" aria-hidden="true" tabindex="-1"></a>    elem_ref[<span class="st">'value'</span>].append({</span>
<span id="annotated-cell-11-14"><a href="#annotated-cell-11-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'EXPR'</span>,</span>
<span id="annotated-cell-11-15"><a href="#annotated-cell-11-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'value'</span>: parsed_subexpression.ast</span>
<span id="annotated-cell-11-16"><a href="#annotated-cell-11-16" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="annotated-cell-11-17"><a href="#annotated-cell-11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-11" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-11" data-code-lines="4" data-code-annotation="1">We break the loop, at the moment that we find a closing bracket in the sequence of tokens, because this character represents the end of the pair of brackets that contains the subexpression that we are analyzing.</span>
</dd>
</dl>
</div>
</div>
<p>After we accumulated the sequence of tokens that represents the subexpression that we are analyzing, we need to parse this subexpression separately. To do that, we create a new <code>ParserCache</code> object with this sequence of tokens that represents this subexpression, or, in other words, with all of the tokens that are between the openning and closing brackets. Then, we just call the <code>_parse_input()</code> over this expression to effectively parse this expression.</p>
<p>After that, we add to the top of the AST a new expression object (<code>EXPR</code>) that contains the AST of parsed subexpression inside of it.</p>
</section>
<section id="parsing-addition-operations" class="level3" data-number="3.4.9">
<h3 data-number="3.4.9" class="anchored" data-anchor-id="parsing-addition-operations"><span class="header-section-number">3.4.9</span> Parsing addition operations</h3>
<p>Now, things get a little bit more complicated when we find a plus sign in the middle of the sequence of tokens. Because if we do find a plus sign, that means that this plus sign is surrounded by operands in the original expression. In other words, this plus sign connects the left operand to the right operand of this addition operation.</p>
<p>In theory, the previous token in the sequence is the left operand of this addition, and the next token in the sequence is the right operand. That means that, just in theory, at the moment we find a plus sign in the sequence of tokens, we can collect the left operand of the addition operation by looking at the previous token, and, we could also collect the right operand by advancing the parser with <code>next_token()</code> and using <code>current_token()</code> to get the next token in the sequence.</p>
<section id="the-challenge" class="level4" data-number="3.4.9.1">
<h4 data-number="3.4.9.1" class="anchored" data-anchor-id="the-challenge"><span class="header-section-number">3.4.9.1</span> The challenge</h4>
<p>However, this is not really true, or, it would be too easy to be true. The real problem, is that the left and right operands could be splitten by the tokenizer into multiple tokens. In other words, there are very commom cases where single calls to <code>current_token()</code> would be insufficient to actually get the complete right or left operands.</p>
<p>That means that the tokenizer step might make the part of identifying where the left and right operands are in the sequence of tokens a difficult task. If you think about how the tokenizer works (see <a href="#lst-tokenizer" class="quarto-xref">Listing&nbsp;3</a>), you will probably be able to find examples where the left or right operands could be composed of multiple tokens, and not just a single token.</p>
<p>Take the expression <code>database + '.events'</code> as an example. Take a look at the tokenizer’s output over this expression. The left operand is the first token (<code>database</code>), but the right operand, is actually the three last tokens in the sequence (<code>['"', '.events', '"']</code>). This means that these three tokens together compose the right operand.</p>
<div id="7106a92e" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tokenizer(<span class="st">'database + ".events"'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>['database ', '+', '"', '.events', '"']</code></pre>
</div>
</div>
<p>As a result, at the moment where the parser is at the plus sign, if we advance the parser with <code>next_token()</code>, and run <code>current_token()</code> we would get only the token <code>"</code>, so the right operand would be incomplete. How do we know that we need to accumulate the next three tokens instead of looking to just one token in the sequence?</p>
</section>
<section id="solving-the-issue-for-the-left-operand" class="level4" data-number="3.4.9.2">
<h4 data-number="3.4.9.2" class="anchored" data-anchor-id="solving-the-issue-for-the-left-operand"><span class="header-section-number">3.4.9.2</span> Solving the issue for the left operand</h4>
<p>For now, lets ignore the right operand and think about the left operand. The left operand is whatever sequence of tokens that are before the plus sign. But, as we saw in the previous section, in some cases, we might need to look 3, 4 or 5 tokens behind to actually get the full left operand, instead of looking at just 1 token behind.</p>
<p>But instead of looking at the previous tokens in the sequence, we could get the left operand by looking at the top of the AST. In other words, the last element in the AST is the previous token already parsed, and we can easily access this last element by calling <code>parser_cache.ast[-1]</code>.</p>
<p>Perfect, after we saved a copy of the left operand inside a <code>left_operand</code> variable, we can delete him from the AST in the parser cache, with <code>del parser_cache.ast[-1]</code>. If we do not delete him now, then, he would become duplicated in the AST at the moment that we add our object for the addition operation to the AST, which contains both left and right operands.</p>
<div id="45bd6c0f" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_addition(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    left_operand <span class="op">=</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now that we managed the left operando, we will deal</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with the right operand in the next section</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="solving-the-issue-for-the-right-operand" class="level4" data-number="3.4.9.3">
<h4 data-number="3.4.9.3" class="anchored" data-anchor-id="solving-the-issue-for-the-right-operand"><span class="header-section-number">3.4.9.3</span> Solving the issue for the right operand</h4>
<p>After we deleted the last element in the AST (which contained the left operand), we can now look for the right operand, which is whatever sequence of tokens that are after the plus sign.</p>
<p>But getting the right operand is unfortunately more complicated. Because of that, let’s concentrate the main logic of getting the right operand into a new separate function called <code>_parse_right_operand()</code>. After we get the right operand, we just return from <code>_parse_addition()</code> with an <code>ADDITION</code> object which contains both left and right operands.</p>
<div id="77e9b27b" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_addition(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    left_operand <span class="op">=</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> parser_cache.ast[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    parser_cache.next_token()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    right_operand <span class="op">=</span> _parse_right_operand(parser_cache)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    parser_cache.ast.append({</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'type'</span>: <span class="st">'ADDITION'</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'left_operand'</span>: left_operand,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">'right_operand'</span>: right_operand</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parser_cache</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, what <code>_parse_right_operand()</code> should do? I think it should iterate through the sequence of tokens that is after the plus sign, parse this sequence of tokens and then, return the parsed AST of this sequence. That is basically what <code>_parse_right_operand()</code> is doing in the function definition below.</p>
<p>We start with a <code>while</code> loop which will use a new stack object to accumulate all the tokens after the plus sign. This loop stops in two situations:</p>
<ol type="1">
<li>If it hits the end of the stream of tokens that the parser is analyzing.</li>
<li>If it hits a new plus sign in the sequence of tokens, which basically means that, the loop found a new addition operation in the sequence of tokens.</li>
</ol>
<p>When the loop stops in situation 1, then, the stack object will contain all of the tokens that represents the right operand. Having that in mind, all we need to do is to create a new temporary <code>ParserCache</code> object with these tokens, and call <code>_parse_input()</code> over it to parse the right operand. Then, <code>_parse_right_operand()</code> will simply return the parsed AST from this operation.</p>
<p>In the other side, if the loop stops in situation 2, that means that, the right operand that we are currently trying to parse, is in fact, the left hand to a new addition operation. In other words, the tokens that we accumulated in the stack object until this very moment, are in fact, the tokens that represents the left operand of this new addition operation that we found.</p>
<p>At <a href="#fig-addition" class="quarto-xref">Figure&nbsp;2</a> we can see this idea visually. Everything that is marked by the light red rectangle is the left operand of that particular addition operation, and everything that is marked by the dark blue rectangle is the right operand of that particular addition operation.</p>
<div id="fig-addition" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../addition.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-addition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Marking the right and left operands in each addition operation
</figcaption>
</figure>
</div>
<p>So, lets consider as an example, that the parser was parsing the expression <code>database + '.' + 'events'</code>. When <code>_parse_right_operand()</code> is parsing the right operand of the first addition (which is <code>'.'</code>), the function is looping through the sequence of tokens. The tokens <code>["'", '.', "'"]</code> are accumulated inside the stack object, until the loop hits the token <code>+</code>, which is second plus sign in the entire input expression. At this point the function understands that it hitted a new addition operation to be parsed.</p>
<p>That is why <code>_parse_right_operand()</code>, in this situation, will call itself recursively to parse the remaining tokens in the sequence, which are the right operand of this new/second addition it founded. The tokens that are accumulated in the stack object, are the left operand of this new/second addition, and they are parsed by <code>_parse_input()</code>.</p>
<p>So in this situation, to get the actual right operand of the first addition, <code>_parse_right_operand()</code> needs to parse this new/second addition operation that if founded. The right operand of the first addition, is the second addition in its entirety, or, you could also interpret that the right operand of the first addition is the second addition already parsed. That is why, in this situation, <code>_parse_right_operand()</code> will call both <code>_parse_input()</code> and itself recursively to parse the right and left operands of this new/second addition operation, and return the <code>ADDITION</code> object that represents this parsed new/second addition.</p>
<p>Having all of these aspects in mind, here is the source code for <code>_parse_right_operand()</code>:</p>
<div id="9f585493" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_right_operand(parser_cache: ParserCache) <span class="op">-&gt;</span> ParserCache:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    stack <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> parser_cache.current_index() <span class="op">&lt;=</span> parser_cache.<span class="bu">len</span>() <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parser_cache.current_token() <span class="op">==</span> <span class="st">"+"</span>:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>            parser_cache.next_token()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>            second_addition_right_operand <span class="op">=</span> _parse_right_operand(parser_cache)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            temp_parse_cache <span class="op">=</span> ParserCache(stack)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            second_addition_left_operand <span class="op">=</span> _parse_input(temp_parse_cache)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                <span class="st">'type'</span>: <span class="st">'ADDITION'</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                <span class="st">'left_operand'</span>: second_addition_left_operand.ast[<span class="dv">0</span>],</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>                <span class="st">'right_operand'</span>: second_addition_right_operand</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        stack.append(parser_cache.current_token())</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        parser_cache.next_token()</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    temp_parse_cache <span class="op">=</span> ParserCache(stack)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    parsed_right_operand <span class="op">=</span> _parse_input(temp_parse_cache)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parsed_right_operand.ast[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="finally-the-parser-is-complete" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="finally-the-parser-is-complete"><span class="header-section-number">3.5</span> Finally! The parser is complete!</h2>
<p>Now our parser is finally complete! We can now test it, and see what AST’s are produced for each example of expressions we have:</p>
<div id="3dd8f2c3" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> example <span class="kw">in</span> EXPRESSION_EXAMPLES:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    parsed_expr <span class="op">=</span> parse(example)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"===================================="</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"  * Input expression: "</span>, example)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"  * Parsed AST: "</span>, parsed_expr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>====================================
  * Input expression:  'platform.blipraw.events'
  * Parsed AST:  [{'type': 'STRING', 'value': ['platform.blipraw.events']}]
====================================
  * Input expression:  "blip" + "." + "events"
  * Parsed AST:  [{'type': 'ADDITION', 'left_operand': {'type': 'STRING', 'value': ['blip']}, 'right_operand': {'type': 'ADDITION', 'left_operand': {'type': 'STRING', 'value': ['.']}, 'right_operand': {'type': 'STRING', 'value': ['events']}}}]
====================================
  * Input expression:  database + "." + table_name
  * Parsed AST:  [{'type': 'ADDITION', 'left_operand': {'type': 'IDENTIFIER', 'value': 'database '}, 'right_operand': {'type': 'ADDITION', 'left_operand': {'type': 'STRING', 'value': ['.']}, 'right_operand': {'type': 'IDENTIFIER', 'value': ' table_name'}}}]
====================================
  * Input expression:  f"{database}.{table_name}"
  * Parsed AST:  [{'type': 'STRING', 'value': [{'type': 'EXPR', 'value': [{'type': 'IDENTIFIER', 'value': 'database'}]}, '.', {'type': 'EXPR', 'value': [{'type': 'IDENTIFIER', 'value': 'table_name'}]}]}]</code></pre>
</div>
</div>
<p>You can see in the above output, that parser I presented here produces an AST which is composed by a list of dict (or JSON) objects which describes the elements of the three. Now that we have this three, we might do a lot of different things with it. As I mentioned before, every compiler uses trees like this to do type checking, to identify dependencies of your source code, and also, to perform optimization processes.</p>
<p>But these operations are out of the scope of this article. Our objective here is complete, which was to show a basic example of a parser written in Python. If you want to take a closer look, you can see the full source code of the parser at <a href="./../parser.py"><code>parser.py</code></a>.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-gries2008" class="csl-entry" role="listitem">
Gries, David, and Fred B. Schneider. 2008. <em>Parsing Techniques: A Practical Guide</em>. 2nd ed. Springer.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>